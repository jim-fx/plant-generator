{"version":3,"file":"index.esm.js","sources":["../src/nodes/Branch.ts","../../../node_modules/ogl-typescript/dist/ogl.es.js","../src/nodes/Gravity.ts","../src/index.ts","../src/nodes/Stem.ts","../src/nodes/Output.ts"],"sourcesContent":["import { join, tube, interpolateSkeleton } from '@plantarium/geometry';\nimport { GeometryResult, PlantNode } from '@types';\n\nconst branchRes = 50;\n\nconst node: PlantNode = {\n  name: 'Branches',\n  type: 'branch',\n\n  outputs: ['plant'],\n\n  state: {\n    input: {\n      type: 'plant',\n      label: 'plant',\n      internal: false,\n    },\n    length: {\n      type: ['number', 'parameter', 'curve'],\n      inputType: 'slider',\n      min: 0,\n      max: 10,\n      step: 0.05,\n      value: 0,\n    },\n    thiccness: {\n      type: 'number',\n      inputType: 'slider',\n      min: 0,\n      max: 1,\n      step: 0.01,\n      value: 0.8,\n    },\n    amount: {\n      type: 'number',\n      min: 0,\n      max: 20,\n      value: 1,\n    },\n  },\n\n  computeNode(parameters) {\n    return {\n      type: 'branch',\n      parameters,\n    };\n  },\n\n  computeSkeleton(part) {\n    const { parameters } = part;\n\n    const { input } = parameters;\n\n    const length = 1;\n    const amount = 2;\n    const thiccness = 0.2;\n    const lowestBranch = 0.5;\n\n    const { skeletons: inputSkeletons } = (input as GeometryResult).result;\n\n    const skeletons: Float32Array[] = inputSkeletons\n      .map((skelly) => {\n        const branches = [];\n        for (let i = 0; i < amount; i++) {\n          const a = i / amount;\n\n          const ci = Math.floor((skelly.length / 4) * a);\n\n          const [x, y, z, t] = interpolateSkeleton(\n            skelly,\n            lowestBranch + a * lowestBranch,\n          );\n\n          const branch = new Float32Array(branchRes * 4);\n          for (let j = 0; j < branchRes * 4; j++) {\n            const _a = j / branchRes;\n\n            branch[j * 4 + 0] = x + _a * length;\n            branch[j * 4 + 1] = y;\n            branch[j * 4 + 2] = z;\n            branch[j * 4 + 3] = t * thiccness * (1 - _a);\n          }\n\n          branches.push(branch);\n        }\n\n        return branches;\n      })\n      .flat();\n\n    console.log('BRANCH', skeletons);\n\n    return {\n      skeletons,\n    };\n  },\n\n  computeGeometry(part, ctx) {\n    const stemResX = ctx.getSetting('stemResX');\n    const {\n      parameters: { input },\n      result: { skeletons },\n    } = part;\n\n    return {\n      geometry: join(\n        (input as GeometryResult).result.geometry,\n        ...skeletons.map((skeleton) => tube(skeleton, stemResX)),\n      ),\n    };\n  },\n};\n\nexport default node;\n","/**\n * Calculates the length of a vec3\n *\n * @param {vec3} a vector to calculate length of\n * @returns {Number} length of a\n */\n\nfunction length(a) {\n  let x = a[0];\n  let y = a[1];\n  let z = a[2];\n  return Math.sqrt(x * x + y * y + z * z);\n}\n/**\n * Copy the values from one vec3 to another\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the source vector\n * @returns {vec3} out\n */\n\nfunction copy(out, a) {\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  return out;\n}\n/**\n * Set the components of a vec3 to the given values\n *\n * @param {vec3} out the receiving vector\n * @param {Number} x X component\n * @param {Number} y Y component\n * @param {Number} z Z component\n * @returns {vec3} out\n */\n\nfunction set(out, x, y, z) {\n  out[0] = x;\n  out[1] = y;\n  out[2] = z;\n  return out;\n}\n/**\n * Adds two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the first operand\n * @param {vec3} b the second operand\n * @returns {vec3} out\n */\n\nfunction add(out, a, b) {\n  out[0] = a[0] + b[0];\n  out[1] = a[1] + b[1];\n  out[2] = a[2] + b[2];\n  return out;\n}\n/**\n * Subtracts vector b from vector a\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the first operand\n * @param {vec3} b the second operand\n * @returns {vec3} out\n */\n\nfunction subtract(out, a, b) {\n  out[0] = a[0] - b[0];\n  out[1] = a[1] - b[1];\n  out[2] = a[2] - b[2];\n  return out;\n}\n/**\n * Multiplies two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the first operand\n * @param {vec3} b the second operand\n * @returns {vec3} out\n */\n\nfunction multiply(out, a, b) {\n  out[0] = a[0] * b[0];\n  out[1] = a[1] * b[1];\n  out[2] = a[2] * b[2];\n  return out;\n}\n/**\n * Divides two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the first operand\n * @param {vec3} b the second operand\n * @returns {vec3} out\n */\n\nfunction divide(out, a, b) {\n  out[0] = a[0] / b[0];\n  out[1] = a[1] / b[1];\n  out[2] = a[2] / b[2];\n  return out;\n}\n/**\n * Scales a vec3 by a scalar number\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the vector to scale\n * @param {Number} b amount to scale the vector by\n * @returns {vec3} out\n */\n\nfunction scale(out, a, b) {\n  out[0] = a[0] * b;\n  out[1] = a[1] * b;\n  out[2] = a[2] * b;\n  return out;\n}\n/**\n * Calculates the euclidian distance between two vec3's\n *\n * @param {vec3} a the first operand\n * @param {vec3} b the second operand\n * @returns {Number} distance between a and b\n */\n\nfunction distance(a, b) {\n  let x = b[0] - a[0];\n  let y = b[1] - a[1];\n  let z = b[2] - a[2];\n  return Math.sqrt(x * x + y * y + z * z);\n}\n/**\n * Calculates the squared euclidian distance between two vec3's\n *\n * @param {vec3} a the first operand\n * @param {vec3} b the second operand\n * @returns {Number} squared distance between a and b\n */\n\nfunction squaredDistance(a, b) {\n  let x = b[0] - a[0];\n  let y = b[1] - a[1];\n  let z = b[2] - a[2];\n  return x * x + y * y + z * z;\n}\n/**\n * Calculates the squared length of a vec3\n *\n * @param {vec3} a vector to calculate squared length of\n * @returns {Number} squared length of a\n */\n\nfunction squaredLength(a) {\n  let x = a[0];\n  let y = a[1];\n  let z = a[2];\n  return x * x + y * y + z * z;\n}\n/**\n * Negates the components of a vec3\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a vector to negate\n * @returns {vec3} out\n */\n\nfunction negate(out, a) {\n  out[0] = -a[0];\n  out[1] = -a[1];\n  out[2] = -a[2];\n  return out;\n}\n/**\n * Returns the inverse of the components of a vec3\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a vector to invert\n * @returns {vec3} out\n */\n\nfunction inverse(out, a) {\n  out[0] = 1.0 / a[0];\n  out[1] = 1.0 / a[1];\n  out[2] = 1.0 / a[2];\n  return out;\n}\n/**\n * Normalize a vec3\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a vector to normalize\n * @returns {vec3} out\n */\n\nfunction normalize(out, a) {\n  let x = a[0];\n  let y = a[1];\n  let z = a[2];\n  let len = x * x + y * y + z * z;\n\n  if (len > 0) {\n    //TODO: evaluate use of glm_invsqrt here?\n    len = 1 / Math.sqrt(len);\n  }\n\n  out[0] = a[0] * len;\n  out[1] = a[1] * len;\n  out[2] = a[2] * len;\n  return out;\n}\n/**\n * Calculates the dot product of two vec3's\n *\n * @param {vec3} a the first operand\n * @param {vec3} b the second operand\n * @returns {Number} dot product of a and b\n */\n\nfunction dot(a, b) {\n  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];\n}\n/**\n * Computes the cross product of two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the first operand\n * @param {vec3} b the second operand\n * @returns {vec3} out\n */\n\nfunction cross(out, a, b) {\n  let ax = a[0],\n      ay = a[1],\n      az = a[2];\n  let bx = b[0],\n      by = b[1],\n      bz = b[2];\n  out[0] = ay * bz - az * by;\n  out[1] = az * bx - ax * bz;\n  out[2] = ax * by - ay * bx;\n  return out;\n}\n/**\n * Performs a linear interpolation between two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the first operand\n * @param {vec3} b the second operand\n * @param {Number} t interpolation amount between the two inputs\n * @returns {vec3} out\n */\n\nfunction lerp(out, a, b, t) {\n  let ax = a[0];\n  let ay = a[1];\n  let az = a[2];\n  out[0] = ax + t * (b[0] - ax);\n  out[1] = ay + t * (b[1] - ay);\n  out[2] = az + t * (b[2] - az);\n  return out;\n}\n/**\n * Transforms the vec3 with a mat4.\n * 4th vector component is implicitly '1'\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the vector to transform\n * @param {mat4} m matrix to transform with\n * @returns {vec3} out\n */\n\nfunction transformMat4(out, a, m) {\n  let x = a[0],\n      y = a[1],\n      z = a[2];\n  let w = m[3] * x + m[7] * y + m[11] * z + m[15];\n  w = w || 1.0;\n  out[0] = (m[0] * x + m[4] * y + m[8] * z + m[12]) / w;\n  out[1] = (m[1] * x + m[5] * y + m[9] * z + m[13]) / w;\n  out[2] = (m[2] * x + m[6] * y + m[10] * z + m[14]) / w;\n  return out;\n}\n/**\n * Same as above but doesn't apply translation.\n * Useful for rays.\n */\n\nfunction scaleRotateMat4(out, a, m) {\n  let x = a[0],\n      y = a[1],\n      z = a[2];\n  let w = m[3] * x + m[7] * y + m[11] * z + m[15];\n  w = w || 1.0;\n  out[0] = (m[0] * x + m[4] * y + m[8] * z) / w;\n  out[1] = (m[1] * x + m[5] * y + m[9] * z) / w;\n  out[2] = (m[2] * x + m[6] * y + m[10] * z) / w;\n  return out;\n}\n/**\n * Transforms the vec3 with a quat\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the vector to transform\n * @param {quat} q quaternion to transform with\n * @returns {vec3} out\n */\n\nfunction transformQuat(out, a, q) {\n  // benchmarks: https://jsperf.com/quaternion-transform-vec3-implementations-fixed\n  let x = a[0],\n      y = a[1],\n      z = a[2];\n  let qx = q[0],\n      qy = q[1],\n      qz = q[2],\n      qw = q[3];\n  let uvx = qy * z - qz * y;\n  let uvy = qz * x - qx * z;\n  let uvz = qx * y - qy * x;\n  let uuvx = qy * uvz - qz * uvy;\n  let uuvy = qz * uvx - qx * uvz;\n  let uuvz = qx * uvy - qy * uvx;\n  let w2 = qw * 2;\n  uvx *= w2;\n  uvy *= w2;\n  uvz *= w2;\n  uuvx *= 2;\n  uuvy *= 2;\n  uuvz *= 2;\n  out[0] = x + uvx + uuvx;\n  out[1] = y + uvy + uuvy;\n  out[2] = z + uvz + uuvz;\n  return out;\n}\n/**\n * Get the angle between two 3D vectors\n * @param {vec3} a The first operand\n * @param {vec3} b The second operand\n * @returns {Number} The angle in radians\n */\n\nconst angle = function () {\n  const tempA = [0, 0, 0];\n  const tempB = [0, 0, 0];\n  return function (a, b) {\n    copy(tempA, a);\n    copy(tempB, b);\n    normalize(tempA, tempA);\n    normalize(tempB, tempB);\n    let cosine = dot(tempA, tempB);\n\n    if (cosine > 1.0) {\n      return 0;\n    } else if (cosine < -1.0) {\n      return Math.PI;\n    } else {\n      return Math.acos(cosine);\n    }\n  };\n}();\n/**\n * Returns whether or not the vectors have exactly the same elements in the same position (when compared with ===)\n *\n * @param {vec3} a The first vector.\n * @param {vec3} b The second vector.\n * @returns {Boolean} True if the vectors are equal, false otherwise.\n */\n\nfunction exactEquals(a, b) {\n  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2];\n}\n\nconst isArrayLike = term => {\n  if (term.length) return true;\n  return false;\n};\nconst isMesh = node => {\n  return !!node.draw;\n};\nconst isWebGl2 = gl => {\n  return gl.renderer.isWebgl2;\n};\n\nclass Vec3 extends Array {\n  // TODO: only be used in Camera class\n  constructor(x = 0, y = x, z = x) {\n    super(x, y, z);\n    this.constant = void 0;\n    return this;\n  }\n\n  get x() {\n    return this[0];\n  }\n\n  get y() {\n    return this[1];\n  }\n\n  get z() {\n    return this[2];\n  }\n\n  set x(v) {\n    this[0] = v;\n  }\n\n  set y(v) {\n    this[1] = v;\n  }\n\n  set z(v) {\n    this[2] = v;\n  }\n\n  set(x, y = x, z = x) {\n    if (isArrayLike(x)) return this.copy(x);\n    set(this, x, y, z);\n    return this;\n  }\n\n  copy(v) {\n    copy(this, v);\n    return this;\n  }\n\n  add(va, vb) {\n    if (vb) add(this, va, vb);else add(this, this, va);\n    return this;\n  }\n\n  sub(va, vb) {\n    if (vb) subtract(this, va, vb);else subtract(this, this, va);\n    return this;\n  }\n\n  multiply(v) {\n    if (v.length) multiply(this, this, v);else scale(this, this, v);\n    return this;\n  }\n\n  divide(v) {\n    if (v.length) divide(this, this, v);else scale(this, this, 1 / v);\n    return this;\n  }\n\n  inverse(v = this) {\n    inverse(this, v);\n    return this;\n  } // Can't use 'length' as Array.prototype uses it\n\n\n  len() {\n    return length(this);\n  }\n\n  distance(v) {\n    if (v) return distance(this, v);else return length(this);\n  }\n\n  squaredLen() {\n    return squaredLength(this);\n  }\n\n  squaredDistance(v) {\n    if (v) return squaredDistance(this, v);else return squaredLength(this);\n  }\n\n  negate(v = this) {\n    negate(this, v);\n    return this;\n  }\n\n  cross(va, vb) {\n    if (vb) cross(this, va, vb);else cross(this, this, va);\n    return this;\n  }\n\n  scale(v) {\n    scale(this, this, v);\n    return this;\n  }\n\n  normalize() {\n    normalize(this, this);\n    return this;\n  }\n\n  dot(v) {\n    return dot(this, v);\n  }\n\n  equals(v) {\n    return exactEquals(this, v);\n  }\n\n  applyMatrix4(mat4) {\n    transformMat4(this, this, mat4);\n    return this;\n  }\n\n  scaleRotateMatrix4(mat4) {\n    scaleRotateMat4(this, this, mat4);\n    return this;\n  }\n\n  applyQuaternion(q) {\n    transformQuat(this, this, q);\n    return this;\n  }\n\n  angle(v) {\n    return angle(this, v);\n  }\n\n  lerp(v, t) {\n    lerp(this, this, v, t);\n    return this;\n  }\n\n  clone() {\n    return new Vec3(this[0], this[1], this[2]);\n  }\n\n  fromArray(a, o = 0) {\n    this[0] = a[o];\n    this[1] = a[o + 1];\n    this[2] = a[o + 2];\n    return this;\n  }\n\n  toArray(a = [], o = 0) {\n    a[o] = this[0];\n    a[o + 1] = this[1];\n    a[o + 2] = this[2];\n    return a;\n  }\n\n  transformDirection(mat4) {\n    const x = this[0];\n    const y = this[1];\n    const z = this[2];\n    this[0] = mat4[0] * x + mat4[4] * y + mat4[8] * z;\n    this[1] = mat4[1] * x + mat4[5] * y + mat4[9] * z;\n    this[2] = mat4[2] * x + mat4[6] * y + mat4[10] * z;\n    return this.normalize();\n  }\n\n}\n\n// attribute params\nconst tempVec3 = new Vec3();\nlet ID = 1;\nlet ATTR_ID = 1; // export interface Attributes {\n//     position: { size: number, data: UInt16Array; },\n//     normal: { size: number, data: normal; },\n//     uv: { size: number, data: uv; },\n//     index: { data: index; },\n// }\n\n// To stop inifinite warnings\nlet isBoundsWarned = false;\nclass Geometry {\n  constructor(gl, attributes = {}) {\n    this.gl = void 0;\n    this.id = void 0;\n    this.attributes = void 0;\n    this.VAOs = void 0;\n    this.drawRange = void 0;\n    this.instancedCount = void 0;\n    this.glState = void 0;\n    this.isInstanced = void 0;\n    this.bounds = void 0;\n    this.raycast = 'box';\n    if (!gl.canvas) console.error('gl not passed as fist argument to Geometry');\n    this.gl = gl;\n    this.attributes = attributes;\n    this.id = ID++; // Store one VAO per program attribute locations order\n\n    this.VAOs = {};\n    this.drawRange = {\n      start: 0,\n      count: 0\n    };\n    this.instancedCount = 0; // Unbind current VAO so that new buffers don't get added to active mesh\n\n    this.gl.renderer.bindVertexArray(null);\n    this.gl.renderer.currentGeometry = null; // Alias for state store to avoid redundant calls for global state\n\n    this.glState = this.gl.renderer.state; // create the buffers\n\n    for (let key in attributes) {\n      this.addAttribute(key, attributes[key]);\n    }\n  }\n\n  addAttribute(key, attr) {\n    this.attributes[key] = attr; // Set options\n\n    attr.id = ATTR_ID++; // TODO: currently unused, remove?\n\n    attr.size = attr.size || 1;\n    attr.type = attr.type || (attr.data.constructor === Float32Array ? this.gl.FLOAT : attr.data.constructor === Uint16Array ? this.gl.UNSIGNED_SHORT : this.gl.UNSIGNED_INT); // Uint32Array\n\n    attr.target = key === 'index' ? this.gl.ELEMENT_ARRAY_BUFFER : this.gl.ARRAY_BUFFER;\n    attr.normalized = attr.normalized || false;\n    attr.stride = attr.stride || 0;\n    attr.offset = attr.offset || 0;\n    attr.count = attr.count || (attr.stride ? attr.data.byteLength / attr.stride : attr.data.length / attr.size);\n    attr.divisor = attr.instanced || 0;\n    attr.needsUpdate = false;\n\n    if (!attr.buffer) {\n      attr.buffer = this.gl.createBuffer(); // Push data to buffer\n\n      this.updateAttribute(attr);\n    } // Update geometry counts. If indexed, ignore regular attributes\n\n\n    if (attr.divisor) {\n      this.isInstanced = true;\n\n      if (this.instancedCount && this.instancedCount !== attr.count * attr.divisor) {\n        console.warn('geometry has multiple instanced buffers of different length');\n        return this.instancedCount = Math.min(this.instancedCount, attr.count * attr.divisor);\n      }\n\n      this.instancedCount = attr.count * attr.divisor;\n    } else if (key === 'index') {\n      this.drawRange.count = attr.count;\n    } else if (!this.attributes.index) {\n      this.drawRange.count = Math.max(this.drawRange.count, attr.count);\n    }\n  }\n\n  updateAttribute(attr) {\n    if (this.glState.boundBuffer !== attr.buffer) {\n      this.gl.bindBuffer(attr.target, attr.buffer);\n      this.glState.boundBuffer = attr.buffer;\n    }\n\n    this.gl.bufferData(attr.target, attr.data, this.gl.STATIC_DRAW);\n    attr.needsUpdate = false;\n  }\n\n  setIndex(value) {\n    this.addAttribute('index', value);\n  }\n\n  setDrawRange(start, count) {\n    this.drawRange.start = start;\n    this.drawRange.count = count;\n  }\n\n  setInstancedCount(value) {\n    this.instancedCount = value;\n  }\n\n  createVAO(program) {\n    this.VAOs[program.attributeOrder] = this.gl.renderer.createVertexArray();\n    this.gl.renderer.bindVertexArray(this.VAOs[program.attributeOrder]);\n    this.bindAttributes(program);\n  }\n\n  bindAttributes(program) {\n    // Link all attributes to program using gl.vertexAttribPointer\n    program.attributeLocations.forEach((location, {\n      name,\n      type\n    }) => {\n      // If geometry missing a required shader attribute\n      if (!this.attributes[name]) {\n        console.warn(`active attribute ${name} not being supplied`);\n        return;\n      }\n\n      const attr = this.attributes[name];\n      this.gl.bindBuffer(attr.target, attr.buffer);\n      this.glState.boundBuffer = attr.buffer; // For matrix attributes, buffer needs to be defined per column\n\n      let numLoc = 1;\n      if (type === 35674) numLoc = 2; // mat2\n\n      if (type === 35675) numLoc = 3; // mat3\n\n      if (type === 35676) numLoc = 4; // mat4\n\n      const size = attr.size / numLoc;\n      const stride = numLoc === 1 ? 0 : numLoc * numLoc * numLoc;\n      const offset = numLoc === 1 ? 0 : numLoc * numLoc;\n\n      for (let i = 0; i < numLoc; i++) {\n        this.gl.vertexAttribPointer(location + i, size, attr.type, attr.normalized, attr.stride + stride, attr.offset + i * offset);\n        this.gl.enableVertexAttribArray(location + i); // For instanced attributes, divisor needs to be set.\n        // For firefox, need to set back to 0 if non-instanced drawn after instanced. Else won't render\n\n        this.gl.renderer.vertexAttribDivisor(location + i, attr.divisor);\n      }\n    }); // Bind indices if geometry indexed\n\n    if (this.attributes.index) this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, this.attributes.index.buffer);\n  }\n\n  draw({\n    program,\n    mode = this.gl.TRIANGLES\n  }) {\n    if (this.gl.renderer.currentGeometry !== `${this.id}_${program.attributeOrder}`) {\n      if (!this.VAOs[program.attributeOrder]) this.createVAO(program);\n      this.gl.renderer.bindVertexArray(this.VAOs[program.attributeOrder]);\n      this.gl.renderer.currentGeometry = `${this.id}_${program.attributeOrder}`;\n    } // Check if any attributes need updating\n\n\n    program.attributeLocations.forEach((location, {\n      name\n    }) => {\n      const attr = this.attributes[name];\n      if (attr.needsUpdate) this.updateAttribute(attr);\n    });\n\n    if (this.isInstanced) {\n      if (this.attributes.index) {\n        this.gl.renderer.drawElementsInstanced(mode, this.drawRange.count, this.attributes.index.type, this.attributes.index.offset + this.drawRange.start * 2, this.instancedCount);\n      } else {\n        this.gl.renderer.drawArraysInstanced(mode, this.drawRange.start, this.drawRange.count, this.instancedCount);\n      }\n    } else {\n      if (this.attributes.index) {\n        this.gl.drawElements(mode, this.drawRange.count, this.attributes.index.type, this.attributes.index.offset + this.drawRange.start * 2);\n      } else {\n        this.gl.drawArrays(mode, this.drawRange.start, this.drawRange.count);\n      }\n    }\n  }\n\n  getPositionArray() {\n    // Use position buffer, or min/max if available\n    const attr = this.attributes.position; // if (attr.min) return [...attr.min, ...attr.max];\n\n    if (attr.data) return attr.data;\n    if (isBoundsWarned) return;\n    console.warn('No position buffer data found to compute bounds');\n    return isBoundsWarned = true;\n  }\n\n  computeBoundingBox(array = null) {\n    if (!array) array = this.getPositionArray();\n\n    if (!this.bounds) {\n      this.bounds = {\n        min: new Vec3(),\n        max: new Vec3(),\n        center: new Vec3(),\n        scale: new Vec3(),\n        radius: Infinity\n      };\n    }\n\n    const min = this.bounds.min;\n    const max = this.bounds.max;\n    const center = this.bounds.center;\n    const scale = this.bounds.scale;\n    min.set(+Infinity);\n    max.set(-Infinity); // TODO: use offset/stride if exists\n    // TODO: check size of position (eg triangle with Vec2)\n\n    for (let i = 0, l = array.length; i < l; i += 3) {\n      const x = array[i];\n      const y = array[i + 1];\n      const z = array[i + 2];\n      min.x = Math.min(x, min.x);\n      min.y = Math.min(y, min.y);\n      min.z = Math.min(z, min.z);\n      max.x = Math.max(x, max.x);\n      max.y = Math.max(y, max.y);\n      max.z = Math.max(z, max.z);\n    }\n\n    scale.sub(max, min);\n    center.add(min, max).divide(2);\n  }\n\n  computeBoundingSphere(array = null) {\n    if (!array) array = this.getPositionArray();\n    if (!this.bounds) this.computeBoundingBox(array);\n    let maxRadiusSq = 0;\n\n    for (let i = 0, l = array.length; i < l; i += 3) {\n      tempVec3.fromArray(array, i);\n      maxRadiusSq = Math.max(maxRadiusSq, this.bounds.center.squaredDistance(tempVec3));\n    }\n\n    this.bounds.radius = Math.sqrt(maxRadiusSq);\n  }\n\n  computeVertexNormals() {\n    const positionAttribute = this.attributes['position'];\n    if (!positionAttribute) return;\n    let normalAttribute = this.attributes['normal'];\n\n    if (!normalAttribute) {\n      this.addAttribute('normal', {\n        size: 3,\n        data: new Float32Array(positionAttribute.count * 3)\n      });\n      normalAttribute = this.attributes['normal'];\n    } else {\n      normalAttribute.data.fill(0);\n    }\n\n    const pA = new Vec3(),\n          pB = new Vec3(),\n          pC = new Vec3();\n    const nA = new Vec3(),\n          nB = new Vec3(),\n          nC = new Vec3();\n    const cb = new Vec3(),\n          ab = new Vec3();\n    const indexAttribute = this.attributes['index'];\n\n    if (indexAttribute) {\n      let iA, iB, iC;\n\n      for (let i = 0, il = indexAttribute.count; i < il; i += 3) {\n        iA = indexAttribute.data[i];\n        iB = indexAttribute.data[i + 1];\n        iC = indexAttribute.data[i + 2]; // copy points\n\n        pA.fromArray(positionAttribute.data, iA * positionAttribute.size);\n        pB.fromArray(positionAttribute.data, iB * positionAttribute.size);\n        pC.fromArray(positionAttribute.data, iC * positionAttribute.size); // cross product two edges to get the face normal\n\n        cb.sub(pC, pB);\n        ab.sub(pA, pB);\n        cb.cross(ab); // read vertex normals \n\n        nA.fromArray(normalAttribute.data, iA * normalAttribute.size);\n        nB.fromArray(normalAttribute.data, iB * normalAttribute.size);\n        nC.fromArray(normalAttribute.data, iC * normalAttribute.size); // add face normal\n\n        nA.add(cb);\n        nB.add(cb);\n        nC.add(cb); // write back\n\n        iA *= normalAttribute.size;\n        normalAttribute.data[iA] = nA.x;\n        normalAttribute.data[iA + 1] = nA.y;\n        normalAttribute.data[iA + 2] = nA.z;\n        iB *= normalAttribute.size;\n        normalAttribute.data[iB] = nB.x;\n        normalAttribute.data[iB + 1] = nB.y;\n        normalAttribute.data[iB + 2] = nB.z;\n        iC *= normalAttribute.size;\n        normalAttribute.data[iC] = nC.x;\n        normalAttribute.data[iC + 1] = nC.y;\n        normalAttribute.data[iC + 2] = nC.z;\n      }\n    } else {\n      // non-indexed elements (unconnected triangle soup)\n      for (let i = 0, il = positionAttribute.count; i < il; i += 3) {\n        pA.fromArray(positionAttribute.data, i * positionAttribute.size);\n        pB.fromArray(positionAttribute.data, (i + 1) * positionAttribute.size);\n        pC.fromArray(positionAttribute.data, (i + 2) * positionAttribute.size);\n        cb.sub(pC, pB);\n        ab.sub(pA, pB);\n        cb.cross(ab);\n        normalAttribute.data[i * normalAttribute.size] = cb.x;\n        normalAttribute.data[i * normalAttribute.size + 1] = cb.y;\n        normalAttribute.data[i * normalAttribute.size + 2] = cb.z;\n        normalAttribute.data[(i + 1) * normalAttribute.size] = cb.x;\n        normalAttribute.data[(i + 1) * normalAttribute.size + 1] = cb.y;\n        normalAttribute.data[(i + 1) * normalAttribute.size + 2] = cb.z;\n        normalAttribute.data[(i + 2) * normalAttribute.size] = cb.x;\n        normalAttribute.data[(i + 2) * normalAttribute.size + 1] = cb.y;\n        normalAttribute.data[(i + 2) * normalAttribute.size + 2] = cb.z;\n      }\n    }\n\n    this.normalizeNormals();\n    normalAttribute.needsUpdate = true;\n  }\n\n  normalizeNormals() {\n    const normals = this.attributes.normal;\n\n    for (let i = 0, il = normals.count; i < il; i++) {\n      tempVec3.fromArray(normals.data, i * normals.size);\n      tempVec3.normalize();\n      normals.data[i * normals.size] = tempVec3.x;\n      normals.data[i * normals.size + 1] = tempVec3.y;\n      normals.data[i * normals.size + 2] = tempVec3.z;\n    }\n  }\n\n  remove() {\n    // if (this.vao) this.gl.renderer.deleteVertexArray(this.vao);\n    for (let key in this.attributes) {\n      this.gl.deleteBuffer(this.attributes[key].buffer);\n      delete this.attributes[key];\n    }\n  }\n\n}\n\n// TODO: upload empty texture if null ? maybe not\n// TODO: upload identity matrix if null ?\n// TODO: sampler Cube\nlet ID$1 = 1; // cache of typed arrays used to flatten uniform arrays\n\nconst arrayCacheF32 = {};\nclass Program {\n  constructor(gl, {\n    vertex,\n    fragment,\n    uniforms = {},\n    transparent = false,\n    cullFace = gl.BACK,\n    frontFace = gl.CCW,\n    depthTest = true,\n    depthWrite = true,\n    depthFunc = gl.LESS\n  } = {}) {\n    this.gl = void 0;\n    this.uniforms = void 0;\n    this.id = void 0;\n    this.transparent = void 0;\n    this.cullFace = void 0;\n    this.frontFace = void 0;\n    this.depthTest = void 0;\n    this.depthWrite = void 0;\n    this.depthFunc = void 0;\n    this.blendFunc = void 0;\n    this.blendEquation = void 0;\n    this.program = void 0;\n    this.uniformLocations = void 0;\n    this.attributeLocations = void 0;\n    this.attributeOrder = void 0;\n    this.gltfMaterial = void 0;\n    if (!gl.canvas) console.error('gl not passed as fist argument to Program');\n    this.gl = gl;\n    this.uniforms = uniforms;\n    this.id = ID$1++;\n    if (!vertex) console.warn('vertex shader not supplied');\n    if (!fragment) console.warn('fragment shader not supplied'); // Store program state\n\n    this.transparent = transparent;\n    this.cullFace = cullFace;\n    this.frontFace = frontFace;\n    this.depthTest = depthTest;\n    this.depthWrite = depthWrite;\n    this.depthFunc = depthFunc;\n    this.blendFunc = {};\n    this.blendEquation = {}; // set default blendFunc if transparent flagged\n\n    if (this.transparent && !this.blendFunc.src) {\n      if (this.gl.renderer.premultipliedAlpha) this.setBlendFunc(this.gl.ONE, this.gl.ONE_MINUS_SRC_ALPHA);else this.setBlendFunc(this.gl.SRC_ALPHA, this.gl.ONE_MINUS_SRC_ALPHA);\n    } // compile vertex shader and log errors\n\n\n    const vertexShader = gl.createShader(gl.VERTEX_SHADER);\n    gl.shaderSource(vertexShader, vertex);\n    gl.compileShader(vertexShader);\n\n    if (gl.getShaderInfoLog(vertexShader) !== '') {\n      console.warn(`${gl.getShaderInfoLog(vertexShader)}\\nVertex Shader\\n${addLineNumbers(vertex)}`);\n    } // compile fragment shader and log errors\n\n\n    const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);\n    gl.shaderSource(fragmentShader, fragment);\n    gl.compileShader(fragmentShader);\n\n    if (gl.getShaderInfoLog(fragmentShader) !== '') {\n      console.warn(`${gl.getShaderInfoLog(fragmentShader)}\\nFragment Shader\\n${addLineNumbers(fragment)}`);\n    } // compile program and log errors\n\n\n    this.program = gl.createProgram();\n    gl.attachShader(this.program, vertexShader);\n    gl.attachShader(this.program, fragmentShader);\n    gl.linkProgram(this.program);\n\n    if (!gl.getProgramParameter(this.program, gl.LINK_STATUS)) {\n      console.warn(gl.getProgramInfoLog(this.program));\n      return;\n    } // Remove shader once linked\n\n\n    gl.deleteShader(vertexShader);\n    gl.deleteShader(fragmentShader); // Get active uniform locations\n\n    this.uniformLocations = new Map();\n    let numUniforms = gl.getProgramParameter(this.program, gl.ACTIVE_UNIFORMS);\n\n    for (let uIndex = 0; uIndex < numUniforms; uIndex++) {\n      let uniform = gl.getActiveUniform(this.program, uIndex);\n      this.uniformLocations.set(uniform, gl.getUniformLocation(this.program, uniform.name)); // split uniforms' names to separate array and struct declarations\n\n      const split = uniform.name.match(/(\\w+)/g);\n      uniform.uniformName = split[0];\n\n      if (split.length === 3) {\n        uniform.isStructArray = true;\n        uniform.structIndex = Number(split[1]);\n        uniform.structProperty = split[2];\n      } else if (split.length === 2 && isNaN(Number(split[1]))) {\n        uniform.isStruct = true;\n        uniform.structProperty = split[1];\n      }\n    } // Get active attribute locations\n\n\n    this.attributeLocations = new Map();\n    const locations = [];\n    const numAttribs = gl.getProgramParameter(this.program, gl.ACTIVE_ATTRIBUTES);\n\n    for (let aIndex = 0; aIndex < numAttribs; aIndex++) {\n      const attribute = gl.getActiveAttrib(this.program, aIndex);\n      const location = gl.getAttribLocation(this.program, attribute.name);\n      locations[location] = attribute.name;\n      this.attributeLocations.set(attribute, location);\n    }\n\n    this.attributeOrder = locations.join('');\n  }\n\n  setBlendFunc(src, dst, srcAlpha, dstAlpha) {\n    this.blendFunc.src = src;\n    this.blendFunc.dst = dst;\n    this.blendFunc.srcAlpha = srcAlpha;\n    this.blendFunc.dstAlpha = dstAlpha;\n    if (src) this.transparent = true;\n  }\n\n  setBlendEquation(modeRGB, modeAlpha) {\n    this.blendEquation.modeRGB = modeRGB;\n    this.blendEquation.modeAlpha = modeAlpha;\n  }\n\n  applyState() {\n    if (this.depthTest) this.gl.renderer.enable(this.gl.DEPTH_TEST);else this.gl.renderer.disable(this.gl.DEPTH_TEST);\n    if (this.cullFace) this.gl.renderer.enable(this.gl.CULL_FACE);else this.gl.renderer.disable(this.gl.CULL_FACE);\n    if (this.blendFunc.src) this.gl.renderer.enable(this.gl.BLEND);else this.gl.renderer.disable(this.gl.BLEND);\n    if (this.cullFace) this.gl.renderer.setCullFace(this.cullFace);\n    this.gl.renderer.setFrontFace(this.frontFace);\n    this.gl.renderer.setDepthMask(this.depthWrite);\n    this.gl.renderer.setDepthFunc(this.depthFunc);\n    if (this.blendFunc.src) this.gl.renderer.setBlendFunc(this.blendFunc.src, this.blendFunc.dst, this.blendFunc.srcAlpha, this.blendFunc.dstAlpha);\n    this.gl.renderer.setBlendEquation(this.blendEquation.modeRGB, this.blendEquation.modeAlpha);\n  }\n\n  use({\n    flipFaces = false\n  } = {}) {\n    let textureUnit = -1;\n    const programActive = this.gl.renderer.currentProgram === this.id; // Avoid gl call if program already in use\n\n    if (!programActive) {\n      this.gl.useProgram(this.program);\n      this.gl.renderer.currentProgram = this.id;\n    } // Set only the active uniforms found in the shader\n\n\n    this.uniformLocations.forEach((location, activeUniform) => {\n      let name = activeUniform.uniformName; // get supplied uniform\n\n      let uniform = this.uniforms[name]; // For structs, get the specific property instead of the entire object\n\n      if (activeUniform.isStruct) {\n        uniform = uniform[activeUniform.structProperty];\n        name += `.${activeUniform.structProperty}`;\n      }\n\n      if (activeUniform.isStructArray) {\n        uniform = uniform[activeUniform.structIndex][activeUniform.structProperty];\n        name += `[${activeUniform.structIndex}].${activeUniform.structProperty}`;\n      }\n\n      if (!uniform) {\n        return warn(`Active uniform ${name} has not been supplied`);\n      }\n\n      if (uniform && uniform.value === undefined) {\n        return warn(`${name} uniform is missing a value parameter`);\n      }\n\n      if (uniform.value.texture) {\n        textureUnit = textureUnit + 1; // Check if texture needs to be updated\n\n        uniform.value.update(textureUnit);\n        return setUniform(this.gl, activeUniform.type, location, textureUnit);\n      } // For texture arrays, set uniform as an array of texture units instead of just one\n\n\n      if (uniform.value.length && uniform.value[0].texture) {\n        const textureUnits = [];\n        uniform.value.forEach(value => {\n          textureUnit = textureUnit + 1;\n          value.update(textureUnit);\n          textureUnits.push(textureUnit);\n        });\n        return setUniform(this.gl, activeUniform.type, location, textureUnits);\n      }\n\n      setUniform(this.gl, activeUniform.type, location, uniform.value);\n    });\n    this.applyState();\n    if (flipFaces) this.gl.renderer.setFrontFace(this.frontFace === this.gl.CCW ? this.gl.CW : this.gl.CCW);\n  }\n\n  remove() {\n    this.gl.deleteProgram(this.program);\n  }\n\n}\n\nfunction setUniform(gl, type, location, value) {\n  value = value.length ? flatten(value) : value;\n  const setValue = gl.renderer.state.uniformLocations.get(location); // Avoid redundant uniform commands\n\n  if (value.length) {\n    if (setValue === undefined || setValue.length !== value.length) {\n      // clone array to store as cache\n      gl.renderer.state.uniformLocations.set(location, value.slice(0));\n    } else {\n      if (arraysEqual(setValue, value)) return; // Update cached array values\n\n      setValue.set ? setValue.set(value) : setArray(setValue, value);\n      gl.renderer.state.uniformLocations.set(location, setValue);\n    }\n  } else {\n    if (setValue === value) return;\n    gl.renderer.state.uniformLocations.set(location, value);\n  }\n\n  switch (type) {\n    case 5126:\n      return value.length ? gl.uniform1fv(location, value) : gl.uniform1f(location, value);\n    // FLOAT\n\n    case 35664:\n      return gl.uniform2fv(location, value);\n    // FLOAT_VEC2\n\n    case 35665:\n      return gl.uniform3fv(location, value);\n    // FLOAT_VEC3\n\n    case 35666:\n      return gl.uniform4fv(location, value);\n    // FLOAT_VEC4\n\n    case 35670: // BOOL\n\n    case 5124: // INT\n\n    case 35678: // SAMPLER_2D\n\n    case 35680:\n      return value.length ? gl.uniform1iv(location, value) : gl.uniform1i(location, value);\n    // SAMPLER_CUBE\n\n    case 35671: // BOOL_VEC2\n\n    case 35667:\n      return gl.uniform2iv(location, value);\n    // INT_VEC2\n\n    case 35672: // BOOL_VEC3\n\n    case 35668:\n      return gl.uniform3iv(location, value);\n    // INT_VEC3\n\n    case 35673: // BOOL_VEC4\n\n    case 35669:\n      return gl.uniform4iv(location, value);\n    // INT_VEC4\n\n    case 35674:\n      return gl.uniformMatrix2fv(location, false, value);\n    // FLOAT_MAT2\n\n    case 35675:\n      return gl.uniformMatrix3fv(location, false, value);\n    // FLOAT_MAT3\n\n    case 35676:\n      return gl.uniformMatrix4fv(location, false, value);\n    // FLOAT_MAT4\n  }\n}\n\nfunction addLineNumbers(string) {\n  let lines = string.split('\\n');\n\n  for (let i = 0; i < lines.length; i++) {\n    lines[i] = i + 1 + ': ' + lines[i];\n  }\n\n  return lines.join('\\n');\n}\n\nfunction flatten(a) {\n  const arrayLen = a.length;\n  const valueLen = a[0].length;\n  if (valueLen === undefined) return a;\n  const length = arrayLen * valueLen;\n  let value = arrayCacheF32[length];\n  if (!value) arrayCacheF32[length] = value = new Float32Array(length);\n\n  for (let i = 0; i < arrayLen; i++) value.set(a[i], i * valueLen);\n\n  return value;\n}\n\nfunction arraysEqual(a, b) {\n  if (a.length !== b.length) return false;\n\n  for (let i = 0, l = a.length; i < l; i++) {\n    if (a[i] !== b[i]) return false;\n  }\n\n  return true;\n}\n\nfunction setArray(a, b) {\n  for (let i = 0, l = a.length; i < l; i++) {\n    a[i] = b[i];\n  }\n}\n\nlet warnCount = 0;\n\nfunction warn(message) {\n  if (warnCount > 100) return;\n  console.warn(message);\n  warnCount++;\n  if (warnCount > 100) console.warn('More than 100 program warnings - stopping logs.');\n}\n\n// Not automatic - devs to use these methods manually\n// gl.colorMask( colorMask, colorMask, colorMask, colorMask );\n// gl.clearColor( r, g, b, a );\n// gl.stencilMask( stencilMask );\n// gl.stencilFunc( stencilFunc, stencilRef, stencilMask );\n// gl.stencilOp( stencilFail, stencilZFail, stencilZPass );\n// gl.clearStencil( stencil );\n\nconst tempVec3$1 = new Vec3();\nlet ID$2 = 1;\nclass Renderer {\n  get id() {\n    return this._id;\n  }\n\n  constructor({\n    canvas = document.createElement('canvas'),\n    width = 300,\n    height = 150,\n    dpr = 1,\n    alpha = false,\n    depth = true,\n    stencil = false,\n    antialias = false,\n    premultipliedAlpha = false,\n    preserveDrawingBuffer = false,\n    powerPreference = 'default',\n    autoClear = true,\n    webgl = 2\n  } = {}) {\n    this.dpr = void 0;\n    this.alpha = void 0;\n    this.color = void 0;\n    this.depth = void 0;\n    this.stencil = void 0;\n    this.premultipliedAlpha = void 0;\n    this.autoClear = void 0;\n    this.gl = void 0;\n    this.isWebgl2 = void 0;\n    this.width = void 0;\n    this.height = void 0;\n    this.parameters = void 0;\n    this.state = void 0;\n    this.extensions = void 0;\n    this.vertexAttribDivisor = void 0;\n    this.drawArraysInstanced = void 0;\n    this.drawElementsInstanced = void 0;\n    this.createVertexArray = void 0;\n    this.bindVertexArray = void 0;\n    this.deleteVertexArray = void 0;\n    this.drawBuffers = void 0;\n    this.currentProgram = void 0;\n    this.currentGeometry = void 0;\n    this._id = void 0;\n    const attributes = {\n      alpha,\n      depth,\n      stencil,\n      antialias,\n      premultipliedAlpha,\n      preserveDrawingBuffer,\n      powerPreference\n    };\n    this.dpr = dpr;\n    this.alpha = alpha;\n    this.color = true;\n    this.depth = depth;\n    this.stencil = stencil;\n    this.premultipliedAlpha = premultipliedAlpha;\n    this.autoClear = autoClear;\n    this._id = ID$2++; // Attempt WebGL2 unless forced to 1, if not supported fallback to WebGL1\n\n    if (webgl === 2) this.gl = canvas.getContext('webgl2', attributes);\n    this.isWebgl2 = !!this.gl;\n\n    if (!this.gl) {\n      this.gl = canvas.getContext('webgl', attributes) || canvas.getContext('experimental-webgl', attributes);\n    } // Attach renderer to gl so that all classes have access to internal state functions\n\n\n    this.gl.renderer = this; // initialise size values\n\n    this.setSize(width, height); // gl state stores to avoid redundant calls on methods used internally\n\n    this.state = {};\n    this.state.blendFunc = {\n      src: this.gl.ONE,\n      dst: this.gl.ZERO\n    };\n    this.state.blendEquation = {\n      modeRGB: this.gl.FUNC_ADD\n    };\n    this.state.cullFace = null;\n    this.state.frontFace = this.gl.CCW;\n    this.state.depthMask = true;\n    this.state.depthFunc = this.gl.LESS;\n    this.state.premultiplyAlpha = false;\n    this.state.flipY = false;\n    this.state.unpackAlignment = 4;\n    this.state.framebuffer = null;\n    this.state.viewport = {\n      width: null,\n      height: null\n    };\n    this.state.textureUnits = [];\n    this.state.activeTextureUnit = 0;\n    this.state.boundBuffer = null;\n    this.state.uniformLocations = new Map(); // store requested extensions\n\n    this.extensions = {}; // Initialise extra format types\n\n    if (this.isWebgl2) {\n      this.getExtension('EXT_color_buffer_float');\n      this.getExtension('OES_texture_float_linear');\n    } else {\n      this.getExtension('OES_texture_float');\n      this.getExtension('OES_texture_float_linear');\n      this.getExtension('OES_texture_half_float');\n      this.getExtension('OES_texture_half_float_linear');\n      this.getExtension('OES_element_index_uint');\n      this.getExtension('OES_standard_derivatives');\n      this.getExtension('EXT_sRGB');\n      this.getExtension('WEBGL_depth_texture');\n      this.getExtension('WEBGL_draw_buffers');\n    } // Create method aliases using extension (WebGL1) or native if available (WebGL2)\n\n\n    this.vertexAttribDivisor = this.getExtension('ANGLE_instanced_arrays', 'vertexAttribDivisor', 'vertexAttribDivisorANGLE');\n    this.drawArraysInstanced = this.getExtension('ANGLE_instanced_arrays', 'drawArraysInstanced', 'drawArraysInstancedANGLE');\n    this.drawElementsInstanced = this.getExtension('ANGLE_instanced_arrays', 'drawElementsInstanced', 'drawElementsInstancedANGLE');\n    this.createVertexArray = this.getExtension('OES_vertex_array_object', 'createVertexArray', 'createVertexArrayOES');\n    this.bindVertexArray = this.getExtension('OES_vertex_array_object', 'bindVertexArray', 'bindVertexArrayOES');\n    this.deleteVertexArray = this.getExtension('OES_vertex_array_object', 'deleteVertexArray', 'deleteVertexArrayOES');\n    this.drawBuffers = this.getExtension('WEBGL_draw_buffers', 'drawBuffers', 'drawBuffersWEBGL'); // Store device parameters\n\n    this.parameters = {};\n    this.parameters.maxTextureUnits = this.gl.getParameter(this.gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS);\n    this.parameters.maxAnisotropy = this.getExtension('EXT_texture_filter_anisotropic') ? this.gl.getParameter(this.getExtension('EXT_texture_filter_anisotropic').MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 0;\n  }\n\n  setSize(width, height) {\n    this.width = width;\n    this.height = height;\n    this.gl.canvas.width = width * this.dpr;\n    this.gl.canvas.height = height * this.dpr;\n    Object.assign(this.gl.canvas.style, {\n      width: width + 'px',\n      height: height + 'px'\n    });\n  }\n\n  setViewport(width, height) {\n    if (this.state.viewport.width === width && this.state.viewport.height === height) return;\n    this.state.viewport.width = width;\n    this.state.viewport.height = height;\n    this.gl.viewport(0, 0, width, height);\n  }\n\n  enable(id) {\n    if (this.state[id] === true) return;\n    this.gl.enable(id);\n    this.state[id] = true;\n  }\n\n  disable(id) {\n    if (this.state[id] === false) return;\n    this.gl.disable(id);\n    this.state[id] = false;\n  }\n\n  setBlendFunc(src, dst, srcAlpha, dstAlpha) {\n    if (this.state.blendFunc.src === src && this.state.blendFunc.dst === dst && this.state.blendFunc.srcAlpha === srcAlpha && this.state.blendFunc.dstAlpha === dstAlpha) return;\n    this.state.blendFunc.src = src;\n    this.state.blendFunc.dst = dst;\n    this.state.blendFunc.srcAlpha = srcAlpha;\n    this.state.blendFunc.dstAlpha = dstAlpha;\n    if (srcAlpha !== undefined) this.gl.blendFuncSeparate(src, dst, srcAlpha, dstAlpha);else this.gl.blendFunc(src, dst);\n  }\n\n  setBlendEquation(modeRGB, modeAlpha) {\n    modeRGB = modeRGB || this.gl.FUNC_ADD;\n    if (this.state.blendEquation.modeRGB === modeRGB && this.state.blendEquation.modeAlpha === modeAlpha) return;\n    this.state.blendEquation.modeRGB = modeRGB;\n    this.state.blendEquation.modeAlpha = modeAlpha;\n    if (modeAlpha !== undefined) this.gl.blendEquationSeparate(modeRGB, modeAlpha);else this.gl.blendEquation(modeRGB);\n  }\n\n  setCullFace(value) {\n    if (this.state.cullFace === value) return;\n    this.state.cullFace = value;\n    this.gl.cullFace(value);\n  }\n\n  setFrontFace(value) {\n    if (this.state.frontFace === value) return;\n    this.state.frontFace = value;\n    this.gl.frontFace(value);\n  }\n\n  setDepthMask(value) {\n    if (this.state.depthMask === value) return;\n    this.state.depthMask = value;\n    this.gl.depthMask(value);\n  }\n\n  setDepthFunc(value) {\n    if (this.state.depthFunc === value) return;\n    this.state.depthFunc = value;\n    this.gl.depthFunc(value);\n  }\n\n  activeTexture(value) {\n    if (this.state.activeTextureUnit === value) return;\n    this.state.activeTextureUnit = value;\n    this.gl.activeTexture(this.gl.TEXTURE0 + value);\n  }\n\n  bindFramebuffer({\n    target = this.gl.FRAMEBUFFER,\n    buffer = null\n  } = {}) {\n    if (this.state.framebuffer === buffer) return;\n    this.state.framebuffer = buffer;\n    this.gl.bindFramebuffer(target, buffer);\n  }\n\n  getExtension(extension, webgl2Func, extFunc) {\n    // if webgl2 function supported, return func bound to gl context\n    if (webgl2Func && this.gl[webgl2Func]) return this.gl[webgl2Func].bind(this.gl); // fetch extension once only\n\n    if (!this.extensions[extension]) {\n      this.extensions[extension] = this.gl.getExtension(extension);\n    } // return extension if no function requested\n\n\n    if (!webgl2Func) return this.extensions[extension]; // Return null if extension not supported\n\n    if (!this.extensions[extension]) return null; // return extension function, bound to extension\n\n    return this.extensions[extension][extFunc].bind(this.extensions[extension]);\n  }\n\n  sortOpaque(a, b) {\n    if (a.renderOrder !== b.renderOrder) {\n      return a.renderOrder - b.renderOrder;\n    } else if (a.program.id !== b.program.id) {\n      return a.program.id - b.program.id;\n    } else if (a.zDepth !== b.zDepth) {\n      return a.zDepth - b.zDepth;\n    } else {\n      return b.id - a.id;\n    }\n  }\n\n  sortTransparent(a, b) {\n    if (a.renderOrder !== b.renderOrder) {\n      return a.renderOrder - b.renderOrder;\n    }\n\n    if (a.zDepth !== b.zDepth) {\n      return b.zDepth - a.zDepth;\n    } else {\n      return b.id - a.id;\n    }\n  }\n\n  sortUI(a, b) {\n    if (a.renderOrder !== b.renderOrder) {\n      return a.renderOrder - b.renderOrder;\n    } else if (a.program.id !== b.program.id) {\n      return a.program.id - b.program.id;\n    } else {\n      return b.id - a.id;\n    }\n  }\n\n  getRenderList({\n    scene,\n    camera,\n    frustumCull,\n    sort\n  }) {\n    let renderList = [];\n    if (camera && frustumCull) camera.updateFrustum(); // Get visible\n\n    scene.traverse(node => {\n      if (!node.visible) return true;\n      if (!isMesh(node)) return; // if (!node.draw) return;\n\n      if (frustumCull && node.frustumCulled && camera) {\n        if (!camera.frustumIntersectsMesh(node)) return;\n      }\n\n      renderList.push(node);\n    });\n\n    if (sort) {\n      const opaque = [];\n      const transparent = []; // depthTest true\n\n      const ui = []; // depthTest false\n\n      renderList.forEach(node => {\n        // Split into the 3 render groups\n        if (!node.program.transparent) {\n          opaque.push(node);\n        } else if (node.program.depthTest) {\n          transparent.push(node);\n        } else {\n          ui.push(node);\n        }\n\n        node.zDepth = 0; // Only calculate z-depth if renderOrder unset and depthTest is true\n\n        if (node.renderOrder !== 0 || !node.program.depthTest || !camera) return; // update z-depth\n\n        node.worldMatrix.getTranslation(tempVec3$1);\n        tempVec3$1.applyMatrix4(camera.projectionViewMatrix);\n        node.zDepth = tempVec3$1.z;\n      });\n      opaque.sort(this.sortOpaque);\n      transparent.sort(this.sortTransparent);\n      ui.sort(this.sortUI);\n      renderList = opaque.concat(transparent, ui);\n    }\n\n    return renderList;\n  }\n\n  render({\n    scene,\n    camera,\n    target = null,\n    update = true,\n    sort = true,\n    frustumCull = true,\n    clear\n  }) {\n    if (target === null) {\n      // make sure no render target bound so draws to canvas\n      this.bindFramebuffer();\n      this.setViewport(this.width * this.dpr, this.height * this.dpr);\n    } else {\n      // bind supplied render target and update viewport\n      this.bindFramebuffer(target);\n      this.setViewport(target.width, target.height);\n    }\n\n    if (clear || this.autoClear && clear !== false) {\n      // Ensure depth buffer writing is enabled so it can be cleared\n      if (this.depth && (!target || target.depth)) {\n        this.enable(this.gl.DEPTH_TEST);\n        this.setDepthMask(true);\n      }\n\n      this.gl.clear((this.color ? this.gl.COLOR_BUFFER_BIT : 0) | (this.depth ? this.gl.DEPTH_BUFFER_BIT : 0) | (this.stencil ? this.gl.STENCIL_BUFFER_BIT : 0));\n    } // updates all scene graph matrices\n\n\n    if (update) scene.updateMatrixWorld(); // Update camera separately, in case not in scene graph\n\n    if (camera) camera.updateMatrixWorld(); // Get render list - entails culling and sorting\n\n    const renderList = this.getRenderList({\n      scene,\n      camera,\n      frustumCull,\n      sort\n    });\n    renderList.forEach(node => {\n      node.draw({\n        camera\n      });\n    });\n  }\n\n}\n\nconst EPSILON = 0.000001;\n/**\n * Copy the values from one mat4 to another\n *\n * @param {mat4} out the receiving matrix\n * @param {mat4} a the source matrix\n * @returns {mat4} out\n */\n\nfunction copy$1(out, a) {\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  out[3] = a[3];\n  out[4] = a[4];\n  out[5] = a[5];\n  out[6] = a[6];\n  out[7] = a[7];\n  out[8] = a[8];\n  out[9] = a[9];\n  out[10] = a[10];\n  out[11] = a[11];\n  out[12] = a[12];\n  out[13] = a[13];\n  out[14] = a[14];\n  out[15] = a[15];\n  return out;\n}\n/**\n * Set the components of a mat4 to the given values\n *\n * @param {mat4} out the receiving matrix\n * @returns {mat4} out\n */\n\nfunction set$1(out, m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {\n  out[0] = m00;\n  out[1] = m01;\n  out[2] = m02;\n  out[3] = m03;\n  out[4] = m10;\n  out[5] = m11;\n  out[6] = m12;\n  out[7] = m13;\n  out[8] = m20;\n  out[9] = m21;\n  out[10] = m22;\n  out[11] = m23;\n  out[12] = m30;\n  out[13] = m31;\n  out[14] = m32;\n  out[15] = m33;\n  return out;\n}\n/**\n * Set a mat4 to the identity matrix\n *\n * @param {mat4} out the receiving matrix\n * @returns {mat4} out\n */\n\nfunction identity(out) {\n  out[0] = 1;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 0;\n  out[5] = 1;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = 0;\n  out[9] = 0;\n  out[10] = 1;\n  out[11] = 0;\n  out[12] = 0;\n  out[13] = 0;\n  out[14] = 0;\n  out[15] = 1;\n  return out;\n}\n/**\n * Inverts a mat4\n *\n * @param {mat4} out the receiving matrix\n * @param {mat4} a the source matrix\n * @returns {mat4} out\n */\n\nfunction invert(out, a) {\n  let a00 = a[0],\n      a01 = a[1],\n      a02 = a[2],\n      a03 = a[3];\n  let a10 = a[4],\n      a11 = a[5],\n      a12 = a[6],\n      a13 = a[7];\n  let a20 = a[8],\n      a21 = a[9],\n      a22 = a[10],\n      a23 = a[11];\n  let a30 = a[12],\n      a31 = a[13],\n      a32 = a[14],\n      a33 = a[15];\n  let b00 = a00 * a11 - a01 * a10;\n  let b01 = a00 * a12 - a02 * a10;\n  let b02 = a00 * a13 - a03 * a10;\n  let b03 = a01 * a12 - a02 * a11;\n  let b04 = a01 * a13 - a03 * a11;\n  let b05 = a02 * a13 - a03 * a12;\n  let b06 = a20 * a31 - a21 * a30;\n  let b07 = a20 * a32 - a22 * a30;\n  let b08 = a20 * a33 - a23 * a30;\n  let b09 = a21 * a32 - a22 * a31;\n  let b10 = a21 * a33 - a23 * a31;\n  let b11 = a22 * a33 - a23 * a32; // Calculate the determinant\n\n  let det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\n\n  if (!det) {\n    return null;\n  }\n\n  det = 1.0 / det;\n  out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;\n  out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;\n  out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;\n  out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;\n  out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;\n  out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;\n  out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;\n  out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;\n  out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;\n  out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;\n  out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;\n  out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;\n  out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;\n  out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;\n  out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;\n  out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;\n  return out;\n}\n/**\n * Calculates the determinant of a mat4\n *\n * @param {mat4} a the source matrix\n * @returns {Number} determinant of a\n */\n\nfunction determinant(a) {\n  let a00 = a[0],\n      a01 = a[1],\n      a02 = a[2],\n      a03 = a[3];\n  let a10 = a[4],\n      a11 = a[5],\n      a12 = a[6],\n      a13 = a[7];\n  let a20 = a[8],\n      a21 = a[9],\n      a22 = a[10],\n      a23 = a[11];\n  let a30 = a[12],\n      a31 = a[13],\n      a32 = a[14],\n      a33 = a[15];\n  let b00 = a00 * a11 - a01 * a10;\n  let b01 = a00 * a12 - a02 * a10;\n  let b02 = a00 * a13 - a03 * a10;\n  let b03 = a01 * a12 - a02 * a11;\n  let b04 = a01 * a13 - a03 * a11;\n  let b05 = a02 * a13 - a03 * a12;\n  let b06 = a20 * a31 - a21 * a30;\n  let b07 = a20 * a32 - a22 * a30;\n  let b08 = a20 * a33 - a23 * a30;\n  let b09 = a21 * a32 - a22 * a31;\n  let b10 = a21 * a33 - a23 * a31;\n  let b11 = a22 * a33 - a23 * a32; // Calculate the determinant\n\n  return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\n}\n/**\n * Multiplies two mat4s\n *\n * @param {mat4} out the receiving matrix\n * @param {mat4} a the first operand\n * @param {mat4} b the second operand\n * @returns {mat4} out\n */\n\nfunction multiply$1(out, a, b) {\n  let a00 = a[0],\n      a01 = a[1],\n      a02 = a[2],\n      a03 = a[3];\n  let a10 = a[4],\n      a11 = a[5],\n      a12 = a[6],\n      a13 = a[7];\n  let a20 = a[8],\n      a21 = a[9],\n      a22 = a[10],\n      a23 = a[11];\n  let a30 = a[12],\n      a31 = a[13],\n      a32 = a[14],\n      a33 = a[15]; // Cache only the current line of the second matrix\n\n  let b0 = b[0],\n      b1 = b[1],\n      b2 = b[2],\n      b3 = b[3];\n  out[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;\n  out[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;\n  out[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;\n  out[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;\n  b0 = b[4];\n  b1 = b[5];\n  b2 = b[6];\n  b3 = b[7];\n  out[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;\n  out[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;\n  out[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;\n  out[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;\n  b0 = b[8];\n  b1 = b[9];\n  b2 = b[10];\n  b3 = b[11];\n  out[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;\n  out[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;\n  out[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;\n  out[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;\n  b0 = b[12];\n  b1 = b[13];\n  b2 = b[14];\n  b3 = b[15];\n  out[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;\n  out[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;\n  out[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;\n  out[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;\n  return out;\n}\n/**\n * Translate a mat4 by the given vector\n *\n * @param {mat4} out the receiving matrix\n * @param {mat4} a the matrix to translate\n * @param {vec3} v vector to translate by\n * @returns {mat4} out\n */\n\nfunction translate(out, a, v) {\n  let x = v[0],\n      y = v[1],\n      z = v[2];\n  let a00, a01, a02, a03;\n  let a10, a11, a12, a13;\n  let a20, a21, a22, a23;\n\n  if (a === out) {\n    out[12] = a[0] * x + a[4] * y + a[8] * z + a[12];\n    out[13] = a[1] * x + a[5] * y + a[9] * z + a[13];\n    out[14] = a[2] * x + a[6] * y + a[10] * z + a[14];\n    out[15] = a[3] * x + a[7] * y + a[11] * z + a[15];\n  } else {\n    a00 = a[0];\n    a01 = a[1];\n    a02 = a[2];\n    a03 = a[3];\n    a10 = a[4];\n    a11 = a[5];\n    a12 = a[6];\n    a13 = a[7];\n    a20 = a[8];\n    a21 = a[9];\n    a22 = a[10];\n    a23 = a[11];\n    out[0] = a00;\n    out[1] = a01;\n    out[2] = a02;\n    out[3] = a03;\n    out[4] = a10;\n    out[5] = a11;\n    out[6] = a12;\n    out[7] = a13;\n    out[8] = a20;\n    out[9] = a21;\n    out[10] = a22;\n    out[11] = a23;\n    out[12] = a00 * x + a10 * y + a20 * z + a[12];\n    out[13] = a01 * x + a11 * y + a21 * z + a[13];\n    out[14] = a02 * x + a12 * y + a22 * z + a[14];\n    out[15] = a03 * x + a13 * y + a23 * z + a[15];\n  }\n\n  return out;\n}\n/**\n * Scales the mat4 by the dimensions in the given vec3 not using vectorization\n *\n * @param {mat4} out the receiving matrix\n * @param {mat4} a the matrix to scale\n * @param {vec3} v the vec3 to scale the matrix by\n * @returns {mat4} out\n **/\n\nfunction scale$1(out, a, v) {\n  let x = v[0],\n      y = v[1],\n      z = v[2];\n  out[0] = a[0] * x;\n  out[1] = a[1] * x;\n  out[2] = a[2] * x;\n  out[3] = a[3] * x;\n  out[4] = a[4] * y;\n  out[5] = a[5] * y;\n  out[6] = a[6] * y;\n  out[7] = a[7] * y;\n  out[8] = a[8] * z;\n  out[9] = a[9] * z;\n  out[10] = a[10] * z;\n  out[11] = a[11] * z;\n  out[12] = a[12];\n  out[13] = a[13];\n  out[14] = a[14];\n  out[15] = a[15];\n  return out;\n}\n/**\n * Rotates a mat4 by the given angle around the given axis\n *\n * @param {mat4} out the receiving matrix\n * @param {mat4} a the matrix to rotate\n * @param {Number} rad the angle to rotate the matrix by\n * @param {vec3} axis the axis to rotate around\n * @returns {mat4} out\n */\n\nfunction rotate(out, a, rad, axis) {\n  let x = axis[0],\n      y = axis[1],\n      z = axis[2];\n  let len = Math.hypot(x, y, z);\n  let s, c, t;\n  let a00, a01, a02, a03;\n  let a10, a11, a12, a13;\n  let a20, a21, a22, a23;\n  let b00, b01, b02;\n  let b10, b11, b12;\n  let b20, b21, b22;\n\n  if (Math.abs(len) < EPSILON) {\n    return null;\n  }\n\n  len = 1 / len;\n  x *= len;\n  y *= len;\n  z *= len;\n  s = Math.sin(rad);\n  c = Math.cos(rad);\n  t = 1 - c;\n  a00 = a[0];\n  a01 = a[1];\n  a02 = a[2];\n  a03 = a[3];\n  a10 = a[4];\n  a11 = a[5];\n  a12 = a[6];\n  a13 = a[7];\n  a20 = a[8];\n  a21 = a[9];\n  a22 = a[10];\n  a23 = a[11]; // Construct the elements of the rotation matrix\n\n  b00 = x * x * t + c;\n  b01 = y * x * t + z * s;\n  b02 = z * x * t - y * s;\n  b10 = x * y * t - z * s;\n  b11 = y * y * t + c;\n  b12 = z * y * t + x * s;\n  b20 = x * z * t + y * s;\n  b21 = y * z * t - x * s;\n  b22 = z * z * t + c; // Perform rotation-specific matrix multiplication\n\n  out[0] = a00 * b00 + a10 * b01 + a20 * b02;\n  out[1] = a01 * b00 + a11 * b01 + a21 * b02;\n  out[2] = a02 * b00 + a12 * b01 + a22 * b02;\n  out[3] = a03 * b00 + a13 * b01 + a23 * b02;\n  out[4] = a00 * b10 + a10 * b11 + a20 * b12;\n  out[5] = a01 * b10 + a11 * b11 + a21 * b12;\n  out[6] = a02 * b10 + a12 * b11 + a22 * b12;\n  out[7] = a03 * b10 + a13 * b11 + a23 * b12;\n  out[8] = a00 * b20 + a10 * b21 + a20 * b22;\n  out[9] = a01 * b20 + a11 * b21 + a21 * b22;\n  out[10] = a02 * b20 + a12 * b21 + a22 * b22;\n  out[11] = a03 * b20 + a13 * b21 + a23 * b22;\n\n  if (a !== out) {\n    // If the source and destination differ, copy the unchanged last row\n    out[12] = a[12];\n    out[13] = a[13];\n    out[14] = a[14];\n    out[15] = a[15];\n  }\n\n  return out;\n}\n/**\n * Returns the translation vector component of a transformation\n *  matrix. If a matrix is built with fromRotationTranslation,\n *  the returned vector will be the same as the translation vector\n *  originally supplied.\n * @param  {vec3} out Vector to receive translation component\n * @param  {mat4} mat Matrix to be decomposed (input)\n * @return {vec3} out\n */\n\nfunction getTranslation(out, mat) {\n  out[0] = mat[12];\n  out[1] = mat[13];\n  out[2] = mat[14];\n  return out;\n}\n/**\n * Returns the scaling factor component of a transformation\n *  matrix. If a matrix is built with fromRotationTranslationScale\n *  with a normalized Quaternion paramter, the returned vector will be\n *  the same as the scaling vector\n *  originally supplied.\n * @param  {vec3} out Vector to receive scaling factor component\n * @param  {mat4} mat Matrix to be decomposed (input)\n * @return {vec3} out\n */\n\nfunction getScaling(out, mat) {\n  let m11 = mat[0];\n  let m12 = mat[1];\n  let m13 = mat[2];\n  let m21 = mat[4];\n  let m22 = mat[5];\n  let m23 = mat[6];\n  let m31 = mat[8];\n  let m32 = mat[9];\n  let m33 = mat[10];\n  out[0] = Math.hypot(m11, m12, m13);\n  out[1] = Math.hypot(m21, m22, m23);\n  out[2] = Math.hypot(m31, m32, m33);\n  return out;\n}\nfunction getMaxScaleOnAxis(mat) {\n  let m11 = mat[0];\n  let m12 = mat[1];\n  let m13 = mat[2];\n  let m21 = mat[4];\n  let m22 = mat[5];\n  let m23 = mat[6];\n  let m31 = mat[8];\n  let m32 = mat[9];\n  let m33 = mat[10];\n  const x = m11 * m11 + m12 * m12 + m13 * m13;\n  const y = m21 * m21 + m22 * m22 + m23 * m23;\n  const z = m31 * m31 + m32 * m32 + m33 * m33;\n  return Math.sqrt(Math.max(x, y, z));\n}\n/**\n * Returns a quaternion representing the rotational component\n *  of a transformation matrix. If a matrix is built with\n *  fromRotationTranslation, the returned quaternion will be the\n *  same as the quaternion originally supplied.\n * @param {quat} out Quaternion to receive the rotation component\n * @param {mat4} mat Matrix to be decomposed (input)\n * @return {quat} out\n */\n\nconst getRotation = function () {\n  const temp = [0, 0, 0];\n  return function (out, mat) {\n    let scaling = temp;\n    getScaling(scaling, mat);\n    let is1 = 1 / scaling[0];\n    let is2 = 1 / scaling[1];\n    let is3 = 1 / scaling[2];\n    let sm11 = mat[0] * is1;\n    let sm12 = mat[1] * is2;\n    let sm13 = mat[2] * is3;\n    let sm21 = mat[4] * is1;\n    let sm22 = mat[5] * is2;\n    let sm23 = mat[6] * is3;\n    let sm31 = mat[8] * is1;\n    let sm32 = mat[9] * is2;\n    let sm33 = mat[10] * is3;\n    let trace = sm11 + sm22 + sm33;\n    let S = 0;\n\n    if (trace > 0) {\n      S = Math.sqrt(trace + 1.0) * 2;\n      out[3] = 0.25 * S;\n      out[0] = (sm23 - sm32) / S;\n      out[1] = (sm31 - sm13) / S;\n      out[2] = (sm12 - sm21) / S;\n    } else if (sm11 > sm22 && sm11 > sm33) {\n      S = Math.sqrt(1.0 + sm11 - sm22 - sm33) * 2;\n      out[3] = (sm23 - sm32) / S;\n      out[0] = 0.25 * S;\n      out[1] = (sm12 + sm21) / S;\n      out[2] = (sm31 + sm13) / S;\n    } else if (sm22 > sm33) {\n      S = Math.sqrt(1.0 + sm22 - sm11 - sm33) * 2;\n      out[3] = (sm31 - sm13) / S;\n      out[0] = (sm12 + sm21) / S;\n      out[1] = 0.25 * S;\n      out[2] = (sm23 + sm32) / S;\n    } else {\n      S = Math.sqrt(1.0 + sm33 - sm11 - sm22) * 2;\n      out[3] = (sm12 - sm21) / S;\n      out[0] = (sm31 + sm13) / S;\n      out[1] = (sm23 + sm32) / S;\n      out[2] = 0.25 * S;\n    }\n\n    return out;\n  };\n}();\n/**\n * Creates a matrix from a quaternion rotation, vector translation and vector scale\n * This is equivalent to (but much faster than):\n *\n *     mat4.identity(dest);\n *     mat4.translate(dest, vec);\n *     let quatMat = mat4.create();\n *     quat4.toMat4(quat, quatMat);\n *     mat4.multiply(dest, quatMat);\n *     mat4.scale(dest, scale)\n *\n * @param {mat4} out mat4 receiving operation result\n * @param {quat4} q Rotation quaternion\n * @param {vec3} v Translation vector\n * @param {vec3} s Scaling vector\n * @returns {mat4} out\n */\n\nfunction fromRotationTranslationScale(out, q, v, s) {\n  // Quaternion math\n  let x = q[0],\n      y = q[1],\n      z = q[2],\n      w = q[3];\n  let x2 = x + x;\n  let y2 = y + y;\n  let z2 = z + z;\n  let xx = x * x2;\n  let xy = x * y2;\n  let xz = x * z2;\n  let yy = y * y2;\n  let yz = y * z2;\n  let zz = z * z2;\n  let wx = w * x2;\n  let wy = w * y2;\n  let wz = w * z2;\n  let sx = s[0];\n  let sy = s[1];\n  let sz = s[2];\n  out[0] = (1 - (yy + zz)) * sx;\n  out[1] = (xy + wz) * sx;\n  out[2] = (xz - wy) * sx;\n  out[3] = 0;\n  out[4] = (xy - wz) * sy;\n  out[5] = (1 - (xx + zz)) * sy;\n  out[6] = (yz + wx) * sy;\n  out[7] = 0;\n  out[8] = (xz + wy) * sz;\n  out[9] = (yz - wx) * sz;\n  out[10] = (1 - (xx + yy)) * sz;\n  out[11] = 0;\n  out[12] = v[0];\n  out[13] = v[1];\n  out[14] = v[2];\n  out[15] = 1;\n  return out;\n}\n/**\n * Calculates a 4x4 matrix from the given quaternion\n *\n * @param {mat4} out mat4 receiving operation result\n * @param {quat} q Quaternion to create matrix from\n *\n * @returns {mat4} out\n */\n\nfunction fromQuat(out, q) {\n  let x = q[0],\n      y = q[1],\n      z = q[2],\n      w = q[3];\n  let x2 = x + x;\n  let y2 = y + y;\n  let z2 = z + z;\n  let xx = x * x2;\n  let yx = y * x2;\n  let yy = y * y2;\n  let zx = z * x2;\n  let zy = z * y2;\n  let zz = z * z2;\n  let wx = w * x2;\n  let wy = w * y2;\n  let wz = w * z2;\n  out[0] = 1 - yy - zz;\n  out[1] = yx + wz;\n  out[2] = zx - wy;\n  out[3] = 0;\n  out[4] = yx - wz;\n  out[5] = 1 - xx - zz;\n  out[6] = zy + wx;\n  out[7] = 0;\n  out[8] = zx + wy;\n  out[9] = zy - wx;\n  out[10] = 1 - xx - yy;\n  out[11] = 0;\n  out[12] = 0;\n  out[13] = 0;\n  out[14] = 0;\n  out[15] = 1;\n  return out;\n}\n/**\n * Generates a perspective projection matrix with the given bounds\n *\n * @param {mat4} out mat4 frustum matrix will be written into\n * @param {number} fovy Vertical field of view in radians\n * @param {number} aspect Aspect ratio. typically viewport width/height\n * @param {number} near Near bound of the frustum\n * @param {number} far Far bound of the frustum\n * @returns {mat4} out\n */\n\nfunction perspective(out, fovy, aspect, near, far) {\n  let f = 1.0 / Math.tan(fovy / 2);\n  let nf = 1 / (near - far);\n  out[0] = f / aspect;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 0;\n  out[5] = f;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = 0;\n  out[9] = 0;\n  out[10] = (far + near) * nf;\n  out[11] = -1;\n  out[12] = 0;\n  out[13] = 0;\n  out[14] = 2 * far * near * nf;\n  out[15] = 0;\n  return out;\n}\n/**\n * Generates a orthogonal projection matrix with the given bounds\n *\n * @param {mat4} out mat4 frustum matrix will be written into\n * @param {number} left Left bound of the frustum\n * @param {number} right Right bound of the frustum\n * @param {number} bottom Bottom bound of the frustum\n * @param {number} top Top bound of the frustum\n * @param {number} near Near bound of the frustum\n * @param {number} far Far bound of the frustum\n * @returns {mat4} out\n */\n\nfunction ortho(out, left, right, bottom, top, near, far) {\n  let lr = 1 / (left - right);\n  let bt = 1 / (bottom - top);\n  let nf = 1 / (near - far);\n  out[0] = -2 * lr;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 0;\n  out[5] = -2 * bt;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = 0;\n  out[9] = 0;\n  out[10] = 2 * nf;\n  out[11] = 0;\n  out[12] = (left + right) * lr;\n  out[13] = (top + bottom) * bt;\n  out[14] = (far + near) * nf;\n  out[15] = 1;\n  return out;\n}\n/**\n * Generates a matrix that makes something look at something else.\n *\n * @param {mat4} out mat4 frustum matrix will be written into\n * @param {vec3} eye Position of the viewer\n * @param {vec3} target Point the viewer is looking at\n * @param {vec3} up vec3 pointing up\n * @returns {mat4} out\n */\n\nfunction targetTo(out, eye, target, up) {\n  let eyex = eye[0],\n      eyey = eye[1],\n      eyez = eye[2],\n      upx = up[0],\n      upy = up[1],\n      upz = up[2];\n  let z0 = eyex - target[0],\n      z1 = eyey - target[1],\n      z2 = eyez - target[2];\n  let len = z0 * z0 + z1 * z1 + z2 * z2;\n\n  if (len === 0) {\n    // eye and target are in the same position\n    z2 = 1;\n  } else {\n    len = 1 / Math.sqrt(len);\n    z0 *= len;\n    z1 *= len;\n    z2 *= len;\n  }\n\n  let x0 = upy * z2 - upz * z1,\n      x1 = upz * z0 - upx * z2,\n      x2 = upx * z1 - upy * z0;\n  len = x0 * x0 + x1 * x1 + x2 * x2;\n\n  if (len === 0) {\n    // up and z are parallel\n    if (upz) {\n      upx += 1e-6;\n    } else if (upy) {\n      upz += 1e-6;\n    } else {\n      upy += 1e-6;\n    }\n\n    x0 = upy * z2 - upz * z1, x1 = upz * z0 - upx * z2, x2 = upx * z1 - upy * z0;\n    len = x0 * x0 + x1 * x1 + x2 * x2;\n  }\n\n  len = 1 / Math.sqrt(len);\n  x0 *= len;\n  x1 *= len;\n  x2 *= len;\n  out[0] = x0;\n  out[1] = x1;\n  out[2] = x2;\n  out[3] = 0;\n  out[4] = z1 * x2 - z2 * x1;\n  out[5] = z2 * x0 - z0 * x2;\n  out[6] = z0 * x1 - z1 * x0;\n  out[7] = 0;\n  out[8] = z0;\n  out[9] = z1;\n  out[10] = z2;\n  out[11] = 0;\n  out[12] = eyex;\n  out[13] = eyey;\n  out[14] = eyez;\n  out[15] = 1;\n  return out;\n}\n\nclass Mat4 extends Array {\n  constructor(m00 = 1, m01 = 0, m02 = 0, m03 = 0, m10 = 0, m11 = 1, m12 = 0, m13 = 0, m20 = 0, m21 = 0, m22 = 1, m23 = 0, m30 = 0, m31 = 0, m32 = 0, m33 = 1) {\n    super(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33);\n    return this;\n  }\n\n  get x() {\n    return this[12];\n  }\n\n  get y() {\n    return this[13];\n  }\n\n  get z() {\n    return this[14];\n  }\n\n  get w() {\n    return this[15];\n  }\n\n  set x(v) {\n    this[12] = v;\n  }\n\n  set y(v) {\n    this[13] = v;\n  }\n\n  set z(v) {\n    this[14] = v;\n  }\n\n  set w(v) {\n    this[15] = v;\n  }\n\n  set(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {\n    if (m00.length) return this.copy(m00);\n    set$1(this, m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33);\n    return this;\n  }\n\n  translate(v, m = this) {\n    translate(this, m, v);\n    return this;\n  }\n\n  rotate(v, axis, m = this) {\n    rotate(this, m, v, axis);\n    return this;\n  }\n\n  scale(v, m = this) {\n    scale$1(this, m, typeof v === 'number' ? [v, v, v] : v);\n    return this;\n  }\n\n  multiply(ma, mb) {\n    if (mb) {\n      multiply$1(this, ma, mb);\n    } else {\n      multiply$1(this, this, ma);\n    }\n\n    return this;\n  }\n\n  identity() {\n    identity(this);\n    return this;\n  }\n\n  copy(m) {\n    copy$1(this, m);\n    return this;\n  }\n\n  fromPerspective({\n    fov,\n    aspect,\n    near,\n    far\n  } = {}) {\n    perspective(this, fov, aspect, near, far);\n    return this;\n  }\n\n  fromOrthogonal({\n    left,\n    right,\n    bottom,\n    top,\n    near,\n    far\n  }) {\n    ortho(this, left, right, bottom, top, near, far);\n    return this;\n  }\n\n  fromQuaternion(q) {\n    fromQuat(this, q);\n    return this;\n  }\n\n  setPosition(v) {\n    this.x = v[0];\n    this.y = v[1];\n    this.z = v[2];\n    return this;\n  }\n\n  inverse(m = this) {\n    invert(this, m);\n    return this;\n  }\n\n  compose(q, pos, scale) {\n    fromRotationTranslationScale(this, q, pos, scale);\n    return this;\n  }\n\n  getRotation(q) {\n    getRotation(q, this);\n    return this;\n  }\n\n  getTranslation(pos) {\n    getTranslation(pos, this);\n    return this;\n  }\n\n  getScaling(scale) {\n    getScaling(scale, this);\n    return this;\n  }\n\n  getMaxScaleOnAxis() {\n    return getMaxScaleOnAxis(this);\n  }\n\n  lookAt(eye, target, up) {\n    targetTo(this, eye, target, up);\n    return this;\n  }\n\n  determinant() {\n    return determinant(this);\n  }\n\n  fromArray(a, o = 0) {\n    this[0] = a[o];\n    this[1] = a[o + 1];\n    this[2] = a[o + 2];\n    this[3] = a[o + 3];\n    this[4] = a[o + 4];\n    this[5] = a[o + 5];\n    this[6] = a[o + 6];\n    this[7] = a[o + 7];\n    this[8] = a[o + 8];\n    this[9] = a[o + 9];\n    this[10] = a[o + 10];\n    this[11] = a[o + 11];\n    this[12] = a[o + 12];\n    this[13] = a[o + 13];\n    this[14] = a[o + 14];\n    this[15] = a[o + 15];\n    return this;\n  }\n\n  toArray(a = [], o = 0) {\n    a[o] = this[0];\n    a[o + 1] = this[1];\n    a[o + 2] = this[2];\n    a[o + 3] = this[3];\n    a[o + 4] = this[4];\n    a[o + 5] = this[5];\n    a[o + 6] = this[6];\n    a[o + 7] = this[7];\n    a[o + 8] = this[8];\n    a[o + 9] = this[9];\n    a[o + 10] = this[10];\n    a[o + 11] = this[11];\n    a[o + 12] = this[12];\n    a[o + 13] = this[13];\n    a[o + 14] = this[14];\n    a[o + 15] = this[15];\n    return a;\n  }\n\n}\n\n/**\n * Copy the values from one vec4 to another\n *\n * @param {vec4} out the receiving vector\n * @param {vec4} a the source vector\n * @returns {vec4} out\n */\n\nfunction copy$2(out, a) {\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  out[3] = a[3];\n  return out;\n}\n/**\n * Set the components of a vec4 to the given values\n *\n * @param {vec4} out the receiving vector\n * @param {Number} x X component\n * @param {Number} y Y component\n * @param {Number} z Z component\n * @param {Number} w W component\n * @returns {vec4} out\n */\n\nfunction set$2(out, x, y, z, w) {\n  out[0] = x;\n  out[1] = y;\n  out[2] = z;\n  out[3] = w;\n  return out;\n}\n/**\n * Normalize a vec4\n *\n * @param {vec4} out the receiving vector\n * @param {vec4} a vector to normalize\n * @returns {vec4} out\n */\n\nfunction normalize$1(out, a) {\n  let x = a[0];\n  let y = a[1];\n  let z = a[2];\n  let w = a[3];\n  let len = x * x + y * y + z * z + w * w;\n\n  if (len > 0) {\n    len = 1 / Math.sqrt(len);\n  }\n\n  out[0] = x * len;\n  out[1] = y * len;\n  out[2] = z * len;\n  out[3] = w * len;\n  return out;\n}\n/**\n * Calculates the dot product of two vec4's\n *\n * @param {vec4} a the first operand\n * @param {vec4} b the second operand\n * @returns {Number} dot product of a and b\n */\n\nfunction dot$1(a, b) {\n  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3];\n}\n\n/**\n * Set a quat to the identity quaternion\n *\n * @param {quat} out the receiving quaternion\n * @returns {quat} out\n */\n\nfunction identity$1(out) {\n  out[0] = 0;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 1;\n  return out;\n}\n/**\n * Sets a quat from the given angle and rotation axis,\n * then returns it.\n *\n * @param {quat} out the receiving quaternion\n * @param {vec3} axis the axis around which to rotate\n * @param {Number} rad the angle in radians\n * @returns {quat} out\n **/\n\nfunction setAxisAngle(out, axis, rad) {\n  rad = rad * 0.5;\n  let s = Math.sin(rad);\n  out[0] = s * axis[0];\n  out[1] = s * axis[1];\n  out[2] = s * axis[2];\n  out[3] = Math.cos(rad);\n  return out;\n}\n/**\n * Multiplies two quats\n *\n * @param {quat} out the receiving quaternion\n * @param {quat} a the first operand\n * @param {quat} b the second operand\n * @returns {quat} out\n */\n\nfunction multiply$2(out, a, b) {\n  let ax = a[0],\n      ay = a[1],\n      az = a[2],\n      aw = a[3];\n  let bx = b[0],\n      by = b[1],\n      bz = b[2],\n      bw = b[3];\n  out[0] = ax * bw + aw * bx + ay * bz - az * by;\n  out[1] = ay * bw + aw * by + az * bx - ax * bz;\n  out[2] = az * bw + aw * bz + ax * by - ay * bx;\n  out[3] = aw * bw - ax * bx - ay * by - az * bz;\n  return out;\n}\n/**\n * Rotates a quaternion by the given angle about the X axis\n *\n * @param {quat} out quat receiving operation result\n * @param {quat} a quat to rotate\n * @param {number} rad angle (in radians) to rotate\n * @returns {quat} out\n */\n\nfunction rotateX(out, a, rad) {\n  rad *= 0.5;\n  let ax = a[0],\n      ay = a[1],\n      az = a[2],\n      aw = a[3];\n  let bx = Math.sin(rad),\n      bw = Math.cos(rad);\n  out[0] = ax * bw + aw * bx;\n  out[1] = ay * bw + az * bx;\n  out[2] = az * bw - ay * bx;\n  out[3] = aw * bw - ax * bx;\n  return out;\n}\n/**\n * Rotates a quaternion by the given angle about the Y axis\n *\n * @param {quat} out quat receiving operation result\n * @param {quat} a quat to rotate\n * @param {number} rad angle (in radians) to rotate\n * @returns {quat} out\n */\n\nfunction rotateY(out, a, rad) {\n  rad *= 0.5;\n  let ax = a[0],\n      ay = a[1],\n      az = a[2],\n      aw = a[3];\n  let by = Math.sin(rad),\n      bw = Math.cos(rad);\n  out[0] = ax * bw - az * by;\n  out[1] = ay * bw + aw * by;\n  out[2] = az * bw + ax * by;\n  out[3] = aw * bw - ay * by;\n  return out;\n}\n/**\n * Rotates a quaternion by the given angle about the Z axis\n *\n * @param {quat} out quat receiving operation result\n * @param {quat} a quat to rotate\n * @param {number} rad angle (in radians) to rotate\n * @returns {quat} out\n */\n\nfunction rotateZ(out, a, rad) {\n  rad *= 0.5;\n  let ax = a[0],\n      ay = a[1],\n      az = a[2],\n      aw = a[3];\n  let bz = Math.sin(rad),\n      bw = Math.cos(rad);\n  out[0] = ax * bw + ay * bz;\n  out[1] = ay * bw - ax * bz;\n  out[2] = az * bw + aw * bz;\n  out[3] = aw * bw - az * bz;\n  return out;\n}\n/**\n * Performs a spherical linear interpolation between two quat\n *\n * @param {quat} out the receiving quaternion\n * @param {quat} a the first operand\n * @param {quat} b the second operand\n * @param {Number} t interpolation amount between the two inputs\n * @returns {quat} out\n */\n\nfunction slerp(out, a, b, t) {\n  // benchmarks:\n  //    http://jsperf.com/quaternion-slerp-implementations\n  let ax = a[0],\n      ay = a[1],\n      az = a[2],\n      aw = a[3];\n  let bx = b[0],\n      by = b[1],\n      bz = b[2],\n      bw = b[3];\n  let omega, cosom, sinom, scale0, scale1; // calc cosine\n\n  cosom = ax * bx + ay * by + az * bz + aw * bw; // adjust signs (if necessary)\n\n  if (cosom < 0.0) {\n    cosom = -cosom;\n    bx = -bx;\n    by = -by;\n    bz = -bz;\n    bw = -bw;\n  } // calculate coefficients\n\n\n  if (1.0 - cosom > 0.000001) {\n    // standard case (slerp)\n    omega = Math.acos(cosom);\n    sinom = Math.sin(omega);\n    scale0 = Math.sin((1.0 - t) * omega) / sinom;\n    scale1 = Math.sin(t * omega) / sinom;\n  } else {\n    // \"from\" and \"to\" quaternions are very close\n    //  ... so we can do a linear interpolation\n    scale0 = 1.0 - t;\n    scale1 = t;\n  } // calculate final values\n\n\n  out[0] = scale0 * ax + scale1 * bx;\n  out[1] = scale0 * ay + scale1 * by;\n  out[2] = scale0 * az + scale1 * bz;\n  out[3] = scale0 * aw + scale1 * bw;\n  return out;\n}\n/**\n * Calculates the inverse of a quat\n *\n * @param {quat} out the receiving quaternion\n * @param {quat} a quat to calculate inverse of\n * @returns {quat} out\n */\n\nfunction invert$1(out, a) {\n  let a0 = a[0],\n      a1 = a[1],\n      a2 = a[2],\n      a3 = a[3];\n  let dot = a0 * a0 + a1 * a1 + a2 * a2 + a3 * a3;\n  let invDot = dot ? 1.0 / dot : 0; // TODO: Would be faster to return [0,0,0,0] immediately if dot == 0\n\n  out[0] = -a0 * invDot;\n  out[1] = -a1 * invDot;\n  out[2] = -a2 * invDot;\n  out[3] = a3 * invDot;\n  return out;\n}\n/**\n * Calculates the conjugate of a quat\n * If the quaternion is normalized, this function is faster than quat.inverse and produces the same result.\n *\n * @param {quat} out the receiving quaternion\n * @param {quat} a quat to calculate conjugate of\n * @returns {quat} out\n */\n\nfunction conjugate(out, a) {\n  out[0] = -a[0];\n  out[1] = -a[1];\n  out[2] = -a[2];\n  out[3] = a[3];\n  return out;\n}\n/**\n * Creates a quaternion from the given 3x3 rotation matrix.\n *\n * NOTE: The resultant quaternion is not normalized, so you should be sure\n * to renormalize the quaternion yourself where necessary.\n *\n * @param {quat} out the receiving quaternion\n * @param {mat3} m rotation matrix\n * @returns {quat} out\n * @function\n */\n\nfunction fromMat3(out, m) {\n  // Algorithm in Ken Shoemake's article in 1987 SIGGRAPH course notes\n  // article \"Quaternion Calculus and Fast Animation\".\n  let fTrace = m[0] + m[4] + m[8];\n  let fRoot;\n\n  if (fTrace > 0.0) {\n    // |w| > 1/2, may as well choose w > 1/2\n    fRoot = Math.sqrt(fTrace + 1.0); // 2w\n\n    out[3] = 0.5 * fRoot;\n    fRoot = 0.5 / fRoot; // 1/(4w)\n\n    out[0] = (m[5] - m[7]) * fRoot;\n    out[1] = (m[6] - m[2]) * fRoot;\n    out[2] = (m[1] - m[3]) * fRoot;\n  } else {\n    // |w| <= 1/2\n    let i = 0;\n    if (m[4] > m[0]) i = 1;\n    if (m[8] > m[i * 3 + i]) i = 2;\n    let j = (i + 1) % 3;\n    let k = (i + 2) % 3;\n    fRoot = Math.sqrt(m[i * 3 + i] - m[j * 3 + j] - m[k * 3 + k] + 1.0);\n    out[i] = 0.5 * fRoot;\n    fRoot = 0.5 / fRoot;\n    out[3] = (m[j * 3 + k] - m[k * 3 + j]) * fRoot;\n    out[j] = (m[j * 3 + i] + m[i * 3 + j]) * fRoot;\n    out[k] = (m[k * 3 + i] + m[i * 3 + k]) * fRoot;\n  }\n\n  return out;\n}\n/**\n * Creates a quaternion from the given euler angle x, y, z.\n *\n * @param {quat} out the receiving quaternion\n * @param {vec3} euler Angles to rotate around each axis in degrees.\n * @param {String} order detailing order of operations. Default 'XYZ'.\n * @returns {quat} out\n * @function\n */\n\nfunction fromEuler(out, euler, order = 'YXZ') {\n  let sx = Math.sin(euler[0] * 0.5);\n  let cx = Math.cos(euler[0] * 0.5);\n  let sy = Math.sin(euler[1] * 0.5);\n  let cy = Math.cos(euler[1] * 0.5);\n  let sz = Math.sin(euler[2] * 0.5);\n  let cz = Math.cos(euler[2] * 0.5);\n\n  if (order === 'XYZ') {\n    out[0] = sx * cy * cz + cx * sy * sz;\n    out[1] = cx * sy * cz - sx * cy * sz;\n    out[2] = cx * cy * sz + sx * sy * cz;\n    out[3] = cx * cy * cz - sx * sy * sz;\n  } else if (order === 'YXZ') {\n    out[0] = sx * cy * cz + cx * sy * sz;\n    out[1] = cx * sy * cz - sx * cy * sz;\n    out[2] = cx * cy * sz - sx * sy * cz;\n    out[3] = cx * cy * cz + sx * sy * sz;\n  } else if (order === 'ZXY') {\n    out[0] = sx * cy * cz - cx * sy * sz;\n    out[1] = cx * sy * cz + sx * cy * sz;\n    out[2] = cx * cy * sz + sx * sy * cz;\n    out[3] = cx * cy * cz - sx * sy * sz;\n  } else if (order === 'ZYX') {\n    out[0] = sx * cy * cz - cx * sy * sz;\n    out[1] = cx * sy * cz + sx * cy * sz;\n    out[2] = cx * cy * sz - sx * sy * cz;\n    out[3] = cx * cy * cz + sx * sy * sz;\n  } else if (order === 'YZX') {\n    out[0] = sx * cy * cz + cx * sy * sz;\n    out[1] = cx * sy * cz + sx * cy * sz;\n    out[2] = cx * cy * sz - sx * sy * cz;\n    out[3] = cx * cy * cz - sx * sy * sz;\n  } else if (order === 'XZY') {\n    out[0] = sx * cy * cz - cx * sy * sz;\n    out[1] = cx * sy * cz - sx * cy * sz;\n    out[2] = cx * cy * sz + sx * sy * cz;\n    out[3] = cx * cy * cz + sx * sy * sz;\n  }\n\n  return out;\n}\n/**\n * Copy the values from one quat to another\n *\n * @param {quat} out the receiving quaternion\n * @param {quat} a the source quaternion\n * @returns {quat} out\n * @function\n */\n\nconst copy$3 = copy$2;\n/**\n * Set the components of a quat to the given values\n *\n * @param {quat} out the receiving quaternion\n * @param {Number} x X component\n * @param {Number} y Y component\n * @param {Number} z Z component\n * @param {Number} w W component\n * @returns {quat} out\n * @function\n */\n\nconst set$3 = set$2;\n/**\n * Calculates the dot product of two quat's\n *\n * @param {quat} a the first operand\n * @param {quat} b the second operand\n * @returns {Number} dot product of a and b\n * @function\n */\n\nconst dot$2 = dot$1;\n/**\n * Normalize a quat\n *\n * @param {quat} out the receiving quaternion\n * @param {quat} a quaternion to normalize\n * @returns {quat} out\n * @function\n */\n\nconst normalize$2 = normalize$1;\n\nclass Quat extends Array {\n  constructor(x = 0, y = 0, z = 0, w = 1) {\n    super(x, y, z, w);\n    this.onChange = void 0;\n\n    this.onChange = () => {};\n\n    return this;\n  }\n\n  get x() {\n    return this[0];\n  }\n\n  get y() {\n    return this[1];\n  }\n\n  get z() {\n    return this[2];\n  }\n\n  get w() {\n    return this[3];\n  }\n\n  set x(v) {\n    this[0] = v;\n    this.onChange();\n  }\n\n  set y(v) {\n    this[1] = v;\n    this.onChange();\n  }\n\n  set z(v) {\n    this[2] = v;\n    this.onChange();\n  }\n\n  set w(v) {\n    this[3] = v;\n    this.onChange();\n  }\n\n  identity() {\n    identity$1(this);\n    this.onChange();\n    return this;\n  }\n\n  set(x, y, z, w) {\n    if (x.length) return this.copy(x);\n    set$3(this, x, y, z, w);\n    this.onChange();\n    return this;\n  }\n\n  rotateX(a) {\n    rotateX(this, this, a);\n    this.onChange();\n    return this;\n  }\n\n  rotateY(a) {\n    rotateY(this, this, a);\n    this.onChange();\n    return this;\n  }\n\n  rotateZ(a) {\n    rotateZ(this, this, a);\n    this.onChange();\n    return this;\n  }\n\n  inverse(q = this) {\n    invert$1(this, q);\n    this.onChange();\n    return this;\n  }\n\n  conjugate(q = this) {\n    conjugate(this, q);\n    this.onChange();\n    return this;\n  }\n\n  copy(q) {\n    copy$3(this, q);\n    this.onChange();\n    return this;\n  }\n\n  normalize(q = this) {\n    normalize$2(this, q);\n    this.onChange();\n    return this;\n  }\n\n  multiply(qA, qB) {\n    if (qB) {\n      multiply$2(this, qA, qB);\n    } else {\n      multiply$2(this, this, qA);\n    }\n\n    this.onChange();\n    return this;\n  }\n\n  dot(v) {\n    return dot$2(this, v);\n  }\n\n  fromMatrix3(matrix3) {\n    fromMat3(this, matrix3);\n    this.onChange();\n    return this;\n  }\n\n  fromEuler(euler) {\n    fromEuler(this, euler, euler.order);\n    return this;\n  }\n\n  fromAxisAngle(axis, a) {\n    setAxisAngle(this, axis, a);\n    return this;\n  }\n\n  slerp(q, t) {\n    slerp(this, this, q, t);\n    return this;\n  }\n\n  fromArray(a, o = 0) {\n    this[0] = a[o];\n    this[1] = a[o + 1];\n    this[2] = a[o + 2];\n    this[3] = a[o + 3];\n    return this;\n  }\n\n  toArray(a = [], o = 0) {\n    a[o] = this[0];\n    a[o + 1] = this[1];\n    a[o + 2] = this[2];\n    a[o + 3] = this[3];\n    return a;\n  }\n\n}\n\n// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\nfunction fromRotationMatrix(out, m, order = 'YXZ') {\n  if (order === 'XYZ') {\n    out[1] = Math.asin(Math.min(Math.max(m[8], -1), 1));\n\n    if (Math.abs(m[8]) < 0.99999) {\n      out[0] = Math.atan2(-m[9], m[10]);\n      out[2] = Math.atan2(-m[4], m[0]);\n    } else {\n      out[0] = Math.atan2(m[6], m[5]);\n      out[2] = 0;\n    }\n  } else if (order === 'YXZ') {\n    out[0] = Math.asin(-Math.min(Math.max(m[9], -1), 1));\n\n    if (Math.abs(m[9]) < 0.99999) {\n      out[1] = Math.atan2(m[8], m[10]);\n      out[2] = Math.atan2(m[1], m[5]);\n    } else {\n      out[1] = Math.atan2(-m[2], m[0]);\n      out[2] = 0;\n    }\n  } else if (order === 'ZXY') {\n    out[0] = Math.asin(Math.min(Math.max(m[6], -1), 1));\n\n    if (Math.abs(m[6]) < 0.99999) {\n      out[1] = Math.atan2(-m[2], m[10]);\n      out[2] = Math.atan2(-m[4], m[5]);\n    } else {\n      out[1] = 0;\n      out[2] = Math.atan2(m[1], m[0]);\n    }\n  } else if (order === 'ZYX') {\n    out[1] = Math.asin(-Math.min(Math.max(m[2], -1), 1));\n\n    if (Math.abs(m[2]) < 0.99999) {\n      out[0] = Math.atan2(m[6], m[10]);\n      out[2] = Math.atan2(m[1], m[0]);\n    } else {\n      out[0] = 0;\n      out[2] = Math.atan2(-m[4], m[5]);\n    }\n  } else if (order === 'YZX') {\n    out[2] = Math.asin(Math.min(Math.max(m[1], -1), 1));\n\n    if (Math.abs(m[1]) < 0.99999) {\n      out[0] = Math.atan2(-m[9], m[5]);\n      out[1] = Math.atan2(-m[2], m[0]);\n    } else {\n      out[0] = 0;\n      out[1] = Math.atan2(m[8], m[10]);\n    }\n  } else if (order === 'XZY') {\n    out[2] = Math.asin(-Math.min(Math.max(m[4], -1), 1));\n\n    if (Math.abs(m[4]) < 0.99999) {\n      out[0] = Math.atan2(m[6], m[5]);\n      out[1] = Math.atan2(m[8], m[0]);\n    } else {\n      out[0] = Math.atan2(-m[9], m[10]);\n      out[1] = 0;\n    }\n  }\n\n  return out;\n}\n\nconst tmpMat4 = new Mat4();\nclass Euler extends Array {\n  constructor(x = 0, y = x, z = x, order = 'YXZ') {\n    super(x, y, z);\n    this.onChange = void 0;\n    this.order = void 0;\n    this.order = order;\n\n    this.onChange = () => {};\n\n    return this;\n  }\n\n  get x() {\n    return this[0];\n  }\n\n  get y() {\n    return this[1];\n  }\n\n  get z() {\n    return this[2];\n  }\n\n  set x(v) {\n    this[0] = v;\n    this.onChange();\n  }\n\n  set y(v) {\n    this[1] = v;\n    this.onChange();\n  }\n\n  set z(v) {\n    this[2] = v;\n    this.onChange();\n  }\n\n  set(x, y = x, z = x) {\n    if (x.length) return this.copy(x);\n    this[0] = x;\n    this[1] = y;\n    this[2] = z;\n    this.onChange();\n    return this;\n  }\n\n  copy(v) {\n    this[0] = v[0];\n    this[1] = v[1];\n    this[2] = v[2];\n    this.onChange();\n    return this;\n  }\n\n  reorder(order) {\n    this.order = order;\n    this.onChange();\n    return this;\n  }\n\n  fromRotationMatrix(m, order = this.order) {\n    fromRotationMatrix(this, m, order);\n    return this;\n  }\n\n  fromQuaternion(q, order = this.order) {\n    tmpMat4.fromQuaternion(q);\n    return this.fromRotationMatrix(tmpMat4, order);\n  }\n\n}\n\nclass Transform {\n  constructor() {\n    this.parent = void 0;\n    this.children = void 0;\n    this.visible = void 0;\n    this.matrix = void 0;\n    this.worldMatrix = void 0;\n    this.matrixAutoUpdate = void 0;\n    this.worldMatrixNeedsUpdate = void 0;\n    this.position = void 0;\n    this.scale = void 0;\n    this.up = void 0;\n    this.quaternion = void 0;\n    this.rotation = void 0;\n    this.parent = null;\n    this.children = [];\n    this.visible = true;\n    this.matrix = new Mat4();\n    this.worldMatrix = new Mat4();\n    this.matrixAutoUpdate = true;\n    this.up = new Vec3(0, 1, 0);\n    this.position = new Vec3();\n    this.scale = new Vec3(1);\n    this.quaternion = new Quat();\n    this.rotation = new Euler();\n\n    this.rotation.onChange = () => this.quaternion.fromEuler(this.rotation);\n\n    this.quaternion.onChange = () => this.rotation.fromQuaternion(this.quaternion);\n  }\n\n  setParent(parent, notifyParent = true) {\n    if (notifyParent && this.parent && parent !== this.parent) this.parent.removeChild(this, false);\n    this.parent = parent;\n    if (notifyParent && parent) parent.addChild(this, false);\n  }\n\n  addChild(child, notifyChild = true) {\n    if (!~this.children.indexOf(child)) this.children.push(child);\n    if (notifyChild) child.setParent(this, false);\n  }\n\n  removeChild(child, notifyChild = true) {\n    if (!!~this.children.indexOf(child)) this.children.splice(this.children.indexOf(child), 1);\n    if (notifyChild) child.setParent(null, false);\n  }\n\n  updateMatrixWorld(force) {\n    if (this.matrixAutoUpdate) this.updateMatrix();\n\n    if (this.worldMatrixNeedsUpdate || force) {\n      if (this.parent === null) this.worldMatrix.copy(this.matrix);else this.worldMatrix.multiply(this.parent.worldMatrix, this.matrix);\n      this.worldMatrixNeedsUpdate = false;\n      force = true;\n    }\n\n    for (let i = 0, l = this.children.length; i < l; i++) {\n      this.children[i].updateMatrixWorld(force);\n    }\n  }\n\n  updateMatrix() {\n    this.matrix.compose(this.quaternion, this.position, this.scale);\n    this.worldMatrixNeedsUpdate = true;\n  }\n\n  traverse(callback) {\n    // Return true in callback to stop traversing children\n    if (callback(this)) return;\n\n    for (let i = 0, l = this.children.length; i < l; i++) {\n      this.children[i].traverse(callback);\n    }\n  }\n\n  decompose() {\n    this.matrix.getTranslation(this.position);\n    this.matrix.getRotation(this.quaternion);\n    this.matrix.getScaling(this.scale);\n    this.rotation.fromQuaternion(this.quaternion);\n  }\n\n  lookAt(target, invert = false) {\n    if (invert) this.matrix.lookAt(this.position, target, this.up);else this.matrix.lookAt(target, this.position, this.up);\n    this.matrix.getRotation(this.quaternion);\n    this.rotation.fromQuaternion(this.quaternion);\n  }\n\n}\n\nconst tempMat4 = new Mat4();\nconst tempVec3a = new Vec3();\nconst tempVec3b = new Vec3();\nclass Camera extends Transform {\n  constructor(gl, {\n    near = 0.1,\n    far = 100,\n    fov = 45,\n    aspect = 1,\n    left,\n    right,\n    bottom,\n    top,\n    zoom = 1\n  } = {}) {\n    super();\n    this.near = void 0;\n    this.far = void 0;\n    this.fov = void 0;\n    this.aspect = void 0;\n    this.left = void 0;\n    this.right = void 0;\n    this.bottom = void 0;\n    this.top = void 0;\n    this.zoom = void 0;\n    this.projectionMatrix = void 0;\n    this.viewMatrix = void 0;\n    this.projectionViewMatrix = void 0;\n    this.worldPosition = void 0;\n    this.type = void 0;\n    this.frustum = void 0;\n    Object.assign(this, {\n      near,\n      far,\n      fov,\n      aspect,\n      left,\n      right,\n      bottom,\n      top,\n      zoom\n    });\n    this.projectionMatrix = new Mat4();\n    this.viewMatrix = new Mat4();\n    this.projectionViewMatrix = new Mat4();\n    this.worldPosition = new Vec3(); // Use orthographic if left/right set, else default to perspective camera\n\n    this.type = left || right ? 'orthographic' : 'perspective';\n    if (this.type === 'orthographic') this.orthographic();else this.perspective();\n  }\n\n  perspective({\n    near = this.near,\n    far = this.far,\n    fov = this.fov,\n    aspect = this.aspect\n  } = {}) {\n    Object.assign(this, {\n      near,\n      far,\n      fov,\n      aspect\n    });\n    this.projectionMatrix.fromPerspective({\n      fov: fov * (Math.PI / 180),\n      aspect,\n      near,\n      far\n    });\n    this.type = 'perspective';\n    return this;\n  }\n\n  orthographic({\n    near = this.near,\n    far = this.far,\n    left = this.left,\n    right = this.right,\n    bottom = this.bottom,\n    top = this.top,\n    zoom = this.zoom\n  } = {}) {\n    Object.assign(this, {\n      near,\n      far,\n      left,\n      right,\n      bottom,\n      top,\n      zoom\n    });\n    left /= zoom;\n    right /= zoom;\n    bottom /= zoom;\n    top /= zoom;\n    this.projectionMatrix.fromOrthogonal({\n      left,\n      right,\n      bottom,\n      top,\n      near,\n      far\n    });\n    this.type = 'orthographic';\n    return this;\n  }\n\n  updateMatrixWorld() {\n    super.updateMatrixWorld();\n    this.viewMatrix.inverse(this.worldMatrix);\n    this.worldMatrix.getTranslation(this.worldPosition); // used for sorting\n\n    this.projectionViewMatrix.multiply(this.projectionMatrix, this.viewMatrix);\n    return this;\n  }\n\n  lookAt(target) {\n    super.lookAt(target, true);\n    return this;\n  } // Project 3D coordinate to 2D point\n\n\n  project(v) {\n    v.applyMatrix4(this.viewMatrix);\n    v.applyMatrix4(this.projectionMatrix);\n    return this;\n  } // Unproject 2D point to 3D coordinate\n\n\n  unproject(v) {\n    v.applyMatrix4(tempMat4.inverse(this.projectionMatrix));\n    v.applyMatrix4(this.worldMatrix);\n    return this;\n  }\n\n  updateFrustum() {\n    if (!this.frustum) {\n      this.frustum = [new Vec3(), new Vec3(), new Vec3(), new Vec3(), new Vec3(), new Vec3()];\n    }\n\n    const m = this.projectionViewMatrix;\n    this.frustum[0].set(m[3] - m[0], m[7] - m[4], m[11] - m[8]).constant = m[15] - m[12]; // -x\n\n    this.frustum[1].set(m[3] + m[0], m[7] + m[4], m[11] + m[8]).constant = m[15] + m[12]; // +x\n\n    this.frustum[2].set(m[3] + m[1], m[7] + m[5], m[11] + m[9]).constant = m[15] + m[13]; // +y\n\n    this.frustum[3].set(m[3] - m[1], m[7] - m[5], m[11] - m[9]).constant = m[15] - m[13]; // -y\n\n    this.frustum[4].set(m[3] - m[2], m[7] - m[6], m[11] - m[10]).constant = m[15] - m[14]; // +z (far)\n\n    this.frustum[5].set(m[3] + m[2], m[7] + m[6], m[11] + m[10]).constant = m[15] + m[14]; // -z (near)\n\n    for (let i = 0; i < 6; i++) {\n      const invLen = 1.0 / this.frustum[i].distance();\n      this.frustum[i].multiply(invLen);\n      this.frustum[i].constant *= invLen;\n    }\n  }\n\n  frustumIntersectsMesh(node) {\n    // If no position attribute, treat as frustumCulled false\n    if (!node.geometry.attributes.position) return true;\n    if (!node.geometry.bounds || node.geometry.bounds.radius === Infinity) node.geometry.computeBoundingSphere();\n    if (!node.geometry.bounds) return true;\n    const center = tempVec3a;\n    center.copy(node.geometry.bounds.center);\n    center.applyMatrix4(node.worldMatrix);\n    const radius = node.geometry.bounds.radius * node.worldMatrix.getMaxScaleOnAxis();\n    return this.frustumIntersectsSphere(center, radius);\n  }\n\n  frustumIntersectsSphere(center, radius) {\n    const normal = tempVec3b;\n\n    for (let i = 0; i < 6; i++) {\n      const plane = this.frustum[i];\n      const distance = normal.copy(plane).dot(center) + plane.constant;\n      if (distance < -radius) return false;\n    }\n\n    return true;\n  }\n\n}\n\n/**\n * Copies the upper-left 3x3 values into the given mat3.\n *\n * @param {mat3} out the receiving 3x3 matrix\n * @param {mat4} a   the source 4x4 matrix\n * @returns {mat3} out\n */\n\nfunction fromMat4(out, a) {\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  out[3] = a[4];\n  out[4] = a[5];\n  out[5] = a[6];\n  out[6] = a[8];\n  out[7] = a[9];\n  out[8] = a[10];\n  return out;\n}\n/**\n * Calculates a 3x3 matrix from the given quaternion\n *\n * @param {mat3} out mat3 receiving operation result\n * @param {quat} q Quaternion to create matrix from\n *\n * @returns {mat3} out\n */\n\nfunction fromQuat$1(out, q) {\n  let x = q[0],\n      y = q[1],\n      z = q[2],\n      w = q[3];\n  let x2 = x + x;\n  let y2 = y + y;\n  let z2 = z + z;\n  let xx = x * x2;\n  let yx = y * x2;\n  let yy = y * y2;\n  let zx = z * x2;\n  let zy = z * y2;\n  let zz = z * z2;\n  let wx = w * x2;\n  let wy = w * y2;\n  let wz = w * z2;\n  out[0] = 1 - yy - zz;\n  out[3] = yx - wz;\n  out[6] = zx + wy;\n  out[1] = yx + wz;\n  out[4] = 1 - xx - zz;\n  out[7] = zy - wx;\n  out[2] = zx - wy;\n  out[5] = zy + wx;\n  out[8] = 1 - xx - yy;\n  return out;\n}\n/**\n * Copy the values from one mat3 to another\n *\n * @param {mat3} out the receiving matrix\n * @param {mat3} a the source matrix\n * @returns {mat3} out\n */\n\nfunction copy$4(out, a) {\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  out[3] = a[3];\n  out[4] = a[4];\n  out[5] = a[5];\n  out[6] = a[6];\n  out[7] = a[7];\n  out[8] = a[8];\n  return out;\n}\n/**\n * Set the components of a mat3 to the given values\n *\n * @param {mat3} out the receiving matrix\n * @returns {mat3} out\n */\n\nfunction set$4(out, m00, m01, m02, m10, m11, m12, m20, m21, m22) {\n  out[0] = m00;\n  out[1] = m01;\n  out[2] = m02;\n  out[3] = m10;\n  out[4] = m11;\n  out[5] = m12;\n  out[6] = m20;\n  out[7] = m21;\n  out[8] = m22;\n  return out;\n}\n/**\n * Set a mat3 to the identity matrix\n *\n * @param {mat3} out the receiving matrix\n * @returns {mat3} out\n */\n\nfunction identity$2(out) {\n  out[0] = 1;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 1;\n  out[5] = 0;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = 1;\n  return out;\n}\n/**\n * Inverts a mat3\n *\n * @param {mat3} out the receiving matrix\n * @param {mat3} a the source matrix\n * @returns {mat3} out\n */\n\nfunction invert$2(out, a) {\n  let a00 = a[0],\n      a01 = a[1],\n      a02 = a[2];\n  let a10 = a[3],\n      a11 = a[4],\n      a12 = a[5];\n  let a20 = a[6],\n      a21 = a[7],\n      a22 = a[8];\n  let b01 = a22 * a11 - a12 * a21;\n  let b11 = -a22 * a10 + a12 * a20;\n  let b21 = a21 * a10 - a11 * a20; // Calculate the determinant\n\n  let det = a00 * b01 + a01 * b11 + a02 * b21;\n\n  if (!det) {\n    return null;\n  }\n\n  det = 1.0 / det;\n  out[0] = b01 * det;\n  out[1] = (-a22 * a01 + a02 * a21) * det;\n  out[2] = (a12 * a01 - a02 * a11) * det;\n  out[3] = b11 * det;\n  out[4] = (a22 * a00 - a02 * a20) * det;\n  out[5] = (-a12 * a00 + a02 * a10) * det;\n  out[6] = b21 * det;\n  out[7] = (-a21 * a00 + a01 * a20) * det;\n  out[8] = (a11 * a00 - a01 * a10) * det;\n  return out;\n}\n/**\n * Multiplies two mat3's\n *\n * @param {mat3} out the receiving matrix\n * @param {mat3} a the first operand\n * @param {mat3} b the second operand\n * @returns {mat3} out\n */\n\nfunction multiply$3(out, a, b) {\n  let a00 = a[0],\n      a01 = a[1],\n      a02 = a[2];\n  let a10 = a[3],\n      a11 = a[4],\n      a12 = a[5];\n  let a20 = a[6],\n      a21 = a[7],\n      a22 = a[8];\n  let b00 = b[0],\n      b01 = b[1],\n      b02 = b[2];\n  let b10 = b[3],\n      b11 = b[4],\n      b12 = b[5];\n  let b20 = b[6],\n      b21 = b[7],\n      b22 = b[8];\n  out[0] = b00 * a00 + b01 * a10 + b02 * a20;\n  out[1] = b00 * a01 + b01 * a11 + b02 * a21;\n  out[2] = b00 * a02 + b01 * a12 + b02 * a22;\n  out[3] = b10 * a00 + b11 * a10 + b12 * a20;\n  out[4] = b10 * a01 + b11 * a11 + b12 * a21;\n  out[5] = b10 * a02 + b11 * a12 + b12 * a22;\n  out[6] = b20 * a00 + b21 * a10 + b22 * a20;\n  out[7] = b20 * a01 + b21 * a11 + b22 * a21;\n  out[8] = b20 * a02 + b21 * a12 + b22 * a22;\n  return out;\n}\n/**\n * Translate a mat3 by the given vector\n *\n * @param {mat3} out the receiving matrix\n * @param {mat3} a the matrix to translate\n * @param {vec2} v vector to translate by\n * @returns {mat3} out\n */\n\nfunction translate$1(out, a, v) {\n  let a00 = a[0],\n      a01 = a[1],\n      a02 = a[2],\n      a10 = a[3],\n      a11 = a[4],\n      a12 = a[5],\n      a20 = a[6],\n      a21 = a[7],\n      a22 = a[8],\n      x = v[0],\n      y = v[1];\n  out[0] = a00;\n  out[1] = a01;\n  out[2] = a02;\n  out[3] = a10;\n  out[4] = a11;\n  out[5] = a12;\n  out[6] = x * a00 + y * a10 + a20;\n  out[7] = x * a01 + y * a11 + a21;\n  out[8] = x * a02 + y * a12 + a22;\n  return out;\n}\n/**\n * Rotates a mat3 by the given angle\n *\n * @param {mat3} out the receiving matrix\n * @param {mat3} a the matrix to rotate\n * @param {Number} rad the angle to rotate the matrix by\n * @returns {mat3} out\n */\n\nfunction rotate$1(out, a, rad) {\n  let a00 = a[0],\n      a01 = a[1],\n      a02 = a[2],\n      a10 = a[3],\n      a11 = a[4],\n      a12 = a[5],\n      a20 = a[6],\n      a21 = a[7],\n      a22 = a[8],\n      s = Math.sin(rad),\n      c = Math.cos(rad);\n  out[0] = c * a00 + s * a10;\n  out[1] = c * a01 + s * a11;\n  out[2] = c * a02 + s * a12;\n  out[3] = c * a10 - s * a00;\n  out[4] = c * a11 - s * a01;\n  out[5] = c * a12 - s * a02;\n  out[6] = a20;\n  out[7] = a21;\n  out[8] = a22;\n  return out;\n}\n/**\n * Scales the mat3 by the dimensions in the given vec2\n *\n * @param {mat3} out the receiving matrix\n * @param {mat3} a the matrix to rotate\n * @param {vec2} v the vec2 to scale the matrix by\n * @returns {mat3} out\n **/\n\nfunction scale$2(out, a, v) {\n  let x = v[0],\n      y = v[1];\n  out[0] = x * a[0];\n  out[1] = x * a[1];\n  out[2] = x * a[2];\n  out[3] = y * a[3];\n  out[4] = y * a[4];\n  out[5] = y * a[5];\n  out[6] = a[6];\n  out[7] = a[7];\n  out[8] = a[8];\n  return out;\n}\n/**\n * Calculates a 3x3 normal matrix (transpose inverse) from the 4x4 matrix\n *\n * @param {mat3} out mat3 receiving operation result\n * @param {mat4} a Mat4 to derive the normal matrix from\n *\n * @returns {mat3} out\n */\n\nfunction normalFromMat4(out, a) {\n  let a00 = a[0],\n      a01 = a[1],\n      a02 = a[2],\n      a03 = a[3];\n  let a10 = a[4],\n      a11 = a[5],\n      a12 = a[6],\n      a13 = a[7];\n  let a20 = a[8],\n      a21 = a[9],\n      a22 = a[10],\n      a23 = a[11];\n  let a30 = a[12],\n      a31 = a[13],\n      a32 = a[14],\n      a33 = a[15];\n  let b00 = a00 * a11 - a01 * a10;\n  let b01 = a00 * a12 - a02 * a10;\n  let b02 = a00 * a13 - a03 * a10;\n  let b03 = a01 * a12 - a02 * a11;\n  let b04 = a01 * a13 - a03 * a11;\n  let b05 = a02 * a13 - a03 * a12;\n  let b06 = a20 * a31 - a21 * a30;\n  let b07 = a20 * a32 - a22 * a30;\n  let b08 = a20 * a33 - a23 * a30;\n  let b09 = a21 * a32 - a22 * a31;\n  let b10 = a21 * a33 - a23 * a31;\n  let b11 = a22 * a33 - a23 * a32; // Calculate the determinant\n\n  let det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\n\n  if (!det) {\n    return null;\n  }\n\n  det = 1.0 / det;\n  out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;\n  out[1] = (a12 * b08 - a10 * b11 - a13 * b07) * det;\n  out[2] = (a10 * b10 - a11 * b08 + a13 * b06) * det;\n  out[3] = (a02 * b10 - a01 * b11 - a03 * b09) * det;\n  out[4] = (a00 * b11 - a02 * b08 + a03 * b07) * det;\n  out[5] = (a01 * b08 - a00 * b10 - a03 * b06) * det;\n  out[6] = (a31 * b05 - a32 * b04 + a33 * b03) * det;\n  out[7] = (a32 * b02 - a30 * b05 - a33 * b01) * det;\n  out[8] = (a30 * b04 - a31 * b02 + a33 * b00) * det;\n  return out;\n}\n\nclass Mat3 extends Array {\n  constructor(m00 = 1, m01 = 0, m02 = 0, m10 = 0, m11 = 1, m12 = 0, m20 = 0, m21 = 0, m22 = 1) {\n    super(m00, m01, m02, m10, m11, m12, m20, m21, m22);\n    return this;\n  }\n\n  set(m00, m01, m02, m10, m11, m12, m20, m21, m22) {\n    if (m00.length) return this.copy(m00);\n    set$4(this, m00, m01, m02, m10, m11, m12, m20, m21, m22);\n    return this;\n  }\n\n  translate(v, m = this) {\n    translate$1(this, m, v);\n    return this;\n  }\n\n  rotate(v, m = this) {\n    rotate$1(this, m, v);\n    return this;\n  }\n\n  scale(v, m = this) {\n    scale$2(this, m, v);\n    return this;\n  }\n\n  multiply(ma, mb) {\n    if (mb) {\n      multiply$3(this, ma, mb);\n    } else {\n      multiply$3(this, this, ma);\n    }\n\n    return this;\n  }\n\n  identity() {\n    identity$2(this);\n    return this;\n  }\n\n  copy(m) {\n    copy$4(this, m);\n    return this;\n  }\n\n  fromMatrix4(m) {\n    fromMat4(this, m);\n    return this;\n  }\n\n  fromQuaternion(q) {\n    fromQuat$1(this, q);\n    return this;\n  }\n\n  fromBasis(vec3a, vec3b, vec3c) {\n    this.set(vec3a[0], vec3a[1], vec3a[2], vec3b[0], vec3b[1], vec3b[2], vec3c[0], vec3c[1], vec3c[2]);\n    return this;\n  }\n\n  inverse(m = this) {\n    invert$2(this, m);\n    return this;\n  }\n\n  getNormalMatrix(m) {\n    normalFromMat4(this, m);\n    return this;\n  }\n\n}\n\nlet ID$3 = 0;\nclass Mesh extends Transform {\n  // raycast.ts\n  constructor(gl, {\n    geometry,\n    program,\n    mode = gl.TRIANGLES,\n    frustumCulled = true,\n    renderOrder = 0\n  } = {}) {\n    super();\n    this.name = void 0;\n    this.numInstances = void 0;\n    this.gl = void 0;\n    this.id = void 0;\n    this.geometry = void 0;\n    this.program = void 0;\n    this.mode = void 0;\n    this.frustumCulled = void 0;\n    this.renderOrder = void 0;\n    this.modelViewMatrix = void 0;\n    this.normalMatrix = void 0;\n    this.beforeRenderCallbacks = void 0;\n    this.afterRenderCallbacks = void 0;\n    this.hit = null;\n    if (!gl.canvas) console.error('gl not passed as first argument to Mesh');\n    this.gl = gl;\n    this.id = ID$3++;\n    this.geometry = geometry;\n    this.program = program;\n    this.mode = mode; // Used to skip frustum culling\n\n    this.frustumCulled = frustumCulled; // Override sorting to force an order\n\n    this.renderOrder = renderOrder;\n    this.modelViewMatrix = new Mat4();\n    this.normalMatrix = new Mat3();\n    this.beforeRenderCallbacks = [];\n    this.afterRenderCallbacks = [];\n  }\n\n  onBeforeRender(f) {\n    this.beforeRenderCallbacks.push(f);\n    return this;\n  }\n\n  onAfterRender(f) {\n    this.afterRenderCallbacks.push(f);\n    return this;\n  }\n\n  draw({\n    camera\n  } = {}) {\n    this.beforeRenderCallbacks.forEach(f => f && f({\n      mesh: this,\n      camera\n    })); // Set the matrix uniforms\n\n    if (camera) {\n      // Add empty matrix uniforms to program if unset\n      if (!this.program.uniforms.modelMatrix) {\n        Object.assign(this.program.uniforms, {\n          modelMatrix: {\n            value: null\n          },\n          viewMatrix: {\n            value: null\n          },\n          modelViewMatrix: {\n            value: null\n          },\n          normalMatrix: {\n            value: null\n          },\n          projectionMatrix: {\n            value: null\n          },\n          cameraPosition: {\n            value: null\n          }\n        });\n      } // Set the matrix uniforms\n\n\n      this.program.uniforms.projectionMatrix.value = camera.projectionMatrix;\n      this.program.uniforms.cameraPosition.value = camera.worldPosition;\n      this.program.uniforms.viewMatrix.value = camera.viewMatrix;\n      this.modelViewMatrix.multiply(camera.viewMatrix, this.worldMatrix);\n      this.normalMatrix.getNormalMatrix(this.modelViewMatrix);\n      this.program.uniforms.modelMatrix.value = this.worldMatrix;\n      this.program.uniforms.modelViewMatrix.value = this.modelViewMatrix;\n      this.program.uniforms.normalMatrix.value = this.normalMatrix;\n    } // determine if faces need to be flipped - when mesh scaled negatively\n\n\n    let flipFaces = this.program.cullFace && this.worldMatrix.determinant() < 0;\n    this.program.use({\n      flipFaces\n    });\n    this.geometry.draw({\n      mode: this.mode,\n      program: this.program\n    });\n    this.afterRenderCallbacks.forEach(f => f && f({\n      mesh: this,\n      camera\n    }));\n  }\n\n}\n\n// TODO: facilitate Compressed Textures\n// TODO: delete texture\n// TODO: check is ArrayBuffer.isView is best way to check for Typed Arrays?\n// TODO: use texSubImage2D for updates\n// TODO: need? encoding = linearEncoding\n// TODO: support non-compressed mipmaps uploads\nconst emptyPixel = new Uint8Array(4);\n\nfunction isPowerOf2(value) {\n  return (value & value - 1) === 0;\n}\n\nlet ID$4 = 1;\n\nconst isCompressedImage = image => image.isCompressedTexture === true;\n\nclass Texture {\n  // options\n  // gl.TEXTURE_2D\n  // gl.UNSIGNED_BYTE,\n  // gl.RGBA,\n  constructor(gl, {\n    image,\n    target = gl.TEXTURE_2D,\n    type = gl.UNSIGNED_BYTE,\n    format = gl.RGBA,\n    internalFormat = format,\n    wrapS = gl.CLAMP_TO_EDGE,\n    wrapT = gl.CLAMP_TO_EDGE,\n    generateMipmaps = true,\n    minFilter = generateMipmaps ? gl.NEAREST_MIPMAP_LINEAR : gl.LINEAR,\n    magFilter = gl.LINEAR,\n    premultiplyAlpha = false,\n    unpackAlignment = 4,\n    flipY = target == gl.TEXTURE_2D ? true : false,\n    anisotropy = 0,\n    level = 0,\n    width,\n    // used for RenderTargets or Data Textures\n    height = width\n  } = {}) {\n    this.ext = void 0;\n    this.gl = void 0;\n    this.id = void 0;\n    this.name = void 0;\n    this.image = void 0;\n    this.target = void 0;\n    this.type = void 0;\n    this.format = void 0;\n    this.internalFormat = void 0;\n    this.wrapS = void 0;\n    this.wrapT = void 0;\n    this.generateMipmaps = void 0;\n    this.minFilter = void 0;\n    this.magFilter = void 0;\n    this.premultiplyAlpha = void 0;\n    this.unpackAlignment = void 0;\n    this.flipY = void 0;\n    this.level = void 0;\n    this.width = void 0;\n    this.height = void 0;\n    this.anisotropy = void 0;\n    this.texture = void 0;\n    this.store = void 0;\n    this.glState = void 0;\n    this.state = void 0;\n    this.needsUpdate = void 0;\n    this.onUpdate = void 0;\n    this.gl = gl;\n    this.id = ID$4++;\n    this.image = image;\n    this.target = target;\n    this.type = type;\n    this.format = format;\n    this.internalFormat = internalFormat;\n    this.minFilter = minFilter;\n    this.magFilter = magFilter;\n    this.wrapS = wrapS;\n    this.wrapT = wrapT;\n    this.generateMipmaps = generateMipmaps;\n    this.premultiplyAlpha = premultiplyAlpha;\n    this.unpackAlignment = unpackAlignment;\n    this.flipY = flipY;\n    this.anisotropy = Math.min(anisotropy, this.gl.renderer.parameters.maxAnisotropy);\n    this.level = level;\n    this.width = width;\n    this.height = height;\n    this.texture = this.gl.createTexture();\n    this.store = {\n      image: null\n    }; // Alias for state store to avoid redundant calls for global state\n\n    this.glState = this.gl.renderer.state; // State store to avoid redundant calls for per-texture state\n\n    this.state = {\n      minFilter: this.gl.NEAREST_MIPMAP_LINEAR,\n      magFilter: this.gl.LINEAR,\n      wrapS: this.gl.REPEAT,\n      wrapT: this.gl.REPEAT,\n      anisotropy: 0\n    };\n  }\n\n  bind() {\n    // Already bound to active texture unit\n    if (this.glState.textureUnits[this.glState.activeTextureUnit] === this.id) return;\n    this.gl.bindTexture(this.target, this.texture);\n    this.glState.textureUnits[this.glState.activeTextureUnit] = this.id;\n  }\n\n  update(textureUnit = 0) {\n    const needsUpdate = !(this.image === this.store.image && !this.needsUpdate); // Make sure that texture is bound to its texture unit\n\n    if (needsUpdate || this.glState.textureUnits[textureUnit] !== this.id) {\n      // set active texture unit to perform texture functions\n      this.gl.renderer.activeTexture(textureUnit);\n      this.bind();\n    }\n\n    if (!needsUpdate) return;\n    this.needsUpdate = false;\n\n    if (this.flipY !== this.glState.flipY) {\n      this.gl.pixelStorei(this.gl.UNPACK_FLIP_Y_WEBGL, this.flipY);\n      this.glState.flipY = this.flipY;\n    }\n\n    if (this.premultiplyAlpha !== this.glState.premultiplyAlpha) {\n      this.gl.pixelStorei(this.gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, this.premultiplyAlpha);\n      this.glState.premultiplyAlpha = this.premultiplyAlpha;\n    }\n\n    if (this.unpackAlignment !== this.glState.unpackAlignment) {\n      this.gl.pixelStorei(this.gl.UNPACK_ALIGNMENT, this.unpackAlignment);\n      this.glState.unpackAlignment = this.unpackAlignment;\n    }\n\n    if (this.minFilter !== this.state.minFilter) {\n      this.gl.texParameteri(this.target, this.gl.TEXTURE_MIN_FILTER, this.minFilter);\n      this.state.minFilter = this.minFilter;\n    }\n\n    if (this.magFilter !== this.state.magFilter) {\n      this.gl.texParameteri(this.target, this.gl.TEXTURE_MAG_FILTER, this.magFilter);\n      this.state.magFilter = this.magFilter;\n    }\n\n    if (this.wrapS !== this.state.wrapS) {\n      this.gl.texParameteri(this.target, this.gl.TEXTURE_WRAP_S, this.wrapS);\n      this.state.wrapS = this.wrapS;\n    }\n\n    if (this.wrapT !== this.state.wrapT) {\n      this.gl.texParameteri(this.target, this.gl.TEXTURE_WRAP_T, this.wrapT);\n      this.state.wrapT = this.wrapT;\n    }\n\n    if (this.anisotropy && this.anisotropy !== this.state.anisotropy) {\n      this.gl.texParameterf(this.target, this.gl.renderer.getExtension('EXT_texture_filter_anisotropic').TEXTURE_MAX_ANISOTROPY_EXT, this.anisotropy);\n      this.state.anisotropy = this.anisotropy;\n    }\n\n    if (this.image) {\n      if (this.image.width) {\n        this.width = this.image.width;\n        this.height = this.image.height;\n      }\n\n      if (this.target === this.gl.TEXTURE_CUBE_MAP) {\n        // For cube maps\n        for (let i = 0; i < 6; i++) {\n          this.gl.texImage2D(this.gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, this.level, this.internalFormat, this.format, this.type, this.image[i]);\n        }\n      } else if (ArrayBuffer.isView(this.image)) {\n        // Data texture\n        this.gl.texImage2D(this.target, this.level, this.internalFormat, this.width, this.height, 0, this.format, this.type, this.image);\n      } else if (isCompressedImage(this.image)) {\n        // Compressed texture\n        let m;\n\n        for (let level = 0; level < this.image.length; level++) {\n          m = this.image[level];\n          this.gl.compressedTexImage2D(this.target, level, this.internalFormat, m.width, m.height, 0, m.data);\n        }\n      } else {\n        // Regular texture\n        this.gl.texImage2D(this.target, this.level, this.internalFormat, this.format, this.type, this.image);\n      }\n\n      if (this.generateMipmaps) {\n        // For WebGL1, if not a power of 2, turn off mips, set wrapping to clamp to edge and minFilter to linear\n        if (!this.gl.renderer.isWebgl2 && (!isPowerOf2(this.image.width) || !isPowerOf2(this.image.height))) {\n          this.generateMipmaps = false;\n          this.wrapS = this.wrapT = this.gl.CLAMP_TO_EDGE;\n          this.minFilter = this.gl.LINEAR;\n        } else {\n          this.gl.generateMipmap(this.target);\n        }\n      } // Callback for when data is pushed to GPU\n\n\n      this.onUpdate && this.onUpdate();\n    } else {\n      if (this.target === this.gl.TEXTURE_CUBE_MAP) {\n        // Upload empty pixel for each side while no image to avoid errors while image or video loading\n        for (let i = 0; i < 6; i++) {\n          this.gl.texImage2D(this.gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, this.gl.RGBA, 1, 1, 0, this.gl.RGBA, this.gl.UNSIGNED_BYTE, emptyPixel);\n        }\n      } else if (this.width) {\n        // image intentionally left null for RenderTarget\n        this.gl.texImage2D(this.target, this.level, this.internalFormat, this.width, this.height, 0, this.format, this.type, null);\n      } else {\n        // Upload empty pixel if no image to avoid errors while image or video loading\n        this.gl.texImage2D(this.target, 0, this.gl.RGBA, 1, 1, 0, this.gl.RGBA, this.gl.UNSIGNED_BYTE, emptyPixel);\n      }\n    }\n\n    this.store.image = this.image;\n  }\n\n}\n\n// TODO: multi target rendering\nclass RenderTarget {\n  constructor(gl, {\n    width = gl.canvas.width,\n    height = gl.canvas.height,\n    target = gl.FRAMEBUFFER,\n    color = 1,\n    // number of color attachments\n    depth = true,\n    stencil = false,\n    depthTexture = false,\n    // note - stencil breaks\n    wrapS = gl.CLAMP_TO_EDGE,\n    wrapT = gl.CLAMP_TO_EDGE,\n    minFilter = gl.LINEAR,\n    magFilter = minFilter,\n    type = gl.UNSIGNED_BYTE,\n    format = gl.RGBA,\n    internalFormat = format,\n    unpackAlignment,\n    premultiplyAlpha\n  } = {}) {\n    this.gl = void 0;\n    this.width = void 0;\n    this.height = void 0;\n    this.depth = void 0;\n    this.buffer = void 0;\n    this.target = void 0;\n    this.textures = void 0;\n    this.texture = void 0;\n    this.depthTexture = void 0;\n    this.depthBuffer = void 0;\n    this.stencilBuffer = void 0;\n    this.depthStencilBuffer = void 0;\n    this.gl = gl;\n    this.width = width;\n    this.height = height;\n    this.depth = depth;\n    this.buffer = this.gl.createFramebuffer();\n    this.target = target;\n    this.gl.bindFramebuffer(this.target, this.buffer);\n    this.textures = [];\n    const drawBuffers = []; // create and attach required num of color textures\n\n    for (let i = 0; i < color; i++) {\n      this.textures.push(new Texture(gl, {\n        width,\n        height,\n        wrapS,\n        wrapT,\n        minFilter,\n        magFilter,\n        type,\n        format,\n        internalFormat,\n        unpackAlignment,\n        premultiplyAlpha,\n        flipY: false,\n        generateMipmaps: false\n      }));\n      this.textures[i].update();\n      this.gl.framebufferTexture2D(this.target, this.gl.COLOR_ATTACHMENT0 + i, this.gl.TEXTURE_2D, this.textures[i].texture, 0\n      /* level */\n      );\n      drawBuffers.push(this.gl.COLOR_ATTACHMENT0 + i);\n    } // For multi-render targets shader access\n\n\n    if (drawBuffers.length > 1) this.gl.renderer.drawBuffers(drawBuffers); // alias for majority of use cases\n\n    this.texture = this.textures[0]; // note depth textures break stencil - so can't use together\n\n    if (depthTexture && (this.gl.renderer.isWebgl2 || this.gl.renderer.getExtension('WEBGL_depth_texture'))) {\n      this.depthTexture = new Texture(gl, {\n        width,\n        height,\n        minFilter: this.gl.NEAREST,\n        magFilter: this.gl.NEAREST,\n        format: this.gl.DEPTH_COMPONENT,\n        internalFormat: gl.renderer.isWebgl2 ? this.gl.DEPTH_COMPONENT16 : this.gl.DEPTH_COMPONENT,\n        type: this.gl.UNSIGNED_INT\n      });\n      this.depthTexture.update();\n      this.gl.framebufferTexture2D(this.target, this.gl.DEPTH_ATTACHMENT, this.gl.TEXTURE_2D, this.depthTexture.texture, 0\n      /* level */\n      );\n    } else {\n      // Render buffers\n      if (depth && !stencil) {\n        this.depthBuffer = this.gl.createRenderbuffer();\n        this.gl.bindRenderbuffer(this.gl.RENDERBUFFER, this.depthBuffer);\n        this.gl.renderbufferStorage(this.gl.RENDERBUFFER, this.gl.DEPTH_COMPONENT16, width, height);\n        this.gl.framebufferRenderbuffer(this.target, this.gl.DEPTH_ATTACHMENT, this.gl.RENDERBUFFER, this.depthBuffer);\n      }\n\n      if (stencil && !depth) {\n        this.stencilBuffer = this.gl.createRenderbuffer();\n        this.gl.bindRenderbuffer(this.gl.RENDERBUFFER, this.stencilBuffer);\n        this.gl.renderbufferStorage(this.gl.RENDERBUFFER, this.gl.STENCIL_INDEX8, width, height);\n        this.gl.framebufferRenderbuffer(this.target, this.gl.STENCIL_ATTACHMENT, this.gl.RENDERBUFFER, this.stencilBuffer);\n      }\n\n      if (depth && stencil) {\n        this.depthStencilBuffer = this.gl.createRenderbuffer();\n        this.gl.bindRenderbuffer(this.gl.RENDERBUFFER, this.depthStencilBuffer);\n        this.gl.renderbufferStorage(this.gl.RENDERBUFFER, this.gl.DEPTH_STENCIL, width, height);\n        this.gl.framebufferRenderbuffer(this.target, this.gl.DEPTH_STENCIL_ATTACHMENT, this.gl.RENDERBUFFER, this.depthStencilBuffer);\n      }\n    }\n\n    this.gl.bindFramebuffer(this.target, null);\n  }\n\n}\n\nconst NAMES = {\n  black: '#000000',\n  white: '#ffffff',\n  red: '#ff0000',\n  green: '#00ff00',\n  blue: '#0000ff',\n  fuchsia: '#ff00ff',\n  cyan: '#00ffff',\n  yellow: '#ffff00',\n  orange: '#ff8000'\n};\nfunction hexToRGB(hex) {\n  if (hex.length === 4) hex = hex[0] + hex[1] + hex[1] + hex[2] + hex[2] + hex[3] + hex[3];\n  const rgb = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i.exec(hex);\n  if (!rgb) console.warn(`Unable to convert hex string ${hex} to rgb values`);\n  return [parseInt(rgb[1], 16) / 255, parseInt(rgb[2], 16) / 255, parseInt(rgb[3], 16) / 255];\n}\nfunction numberToRGB(num) {\n  num = parseInt(num);\n  return [(num >> 16 & 255) / 255, (num >> 8 & 255) / 255, (num & 255) / 255];\n}\nfunction parseColor(color = null) {\n  // Empty\n  if (!color) return [0, 0, 0]; // Decimal\n\n  if (arguments.length === 3) return arguments; // Number\n\n  if (!isNaN(color)) return numberToRGB(color); // Hex\n\n  if (color[0] === '#') return hexToRGB(color); // Names\n\n  if (NAMES[color.toLowerCase()]) return hexToRGB(NAMES[color.toLowerCase()]);\n  console.warn('Color format not recognised');\n  return [0, 0, 0];\n}\n\n// Constructor and set method accept following formats:\n// new Color() - Empty (defaults to black)\n// new Color([0.2, 0.4, 1.0]) - Decimal Array (or another Color instance)\n// new Color(0.7, 0.0, 0.1) - Decimal RGB values\n// new Color('#ff0000') - Hex string\n// new Color('#ccc') - Short-hand Hex string\n// new Color(0x4f27e8) - Number\n// new Color('red') - Color name string (short list in ColorFunc.js)\n\nclass Color extends Array {\n  constructor(color = null) {\n    if (Array.isArray(color)) {\n      super(...color);\n    } else {\n      super(...parseColor(...arguments));\n    }\n  }\n\n  get r() {\n    return this[0];\n  }\n\n  get g() {\n    return this[1];\n  }\n\n  get b() {\n    return this[2];\n  }\n\n  set r(v) {\n    this[0] = v;\n  }\n\n  set g(v) {\n    this[1] = v;\n  }\n\n  set b(v) {\n    this[2] = v;\n  }\n\n  set(color) {\n    if (Array.isArray(color)) return this.copy(color);\n    return this.copy(parseColor(...arguments));\n  }\n\n  copy(v) {\n    this[0] = v[0];\n    this[1] = v[1];\n    this[2] = v[2];\n    return this;\n  }\n\n}\n\n/**\n * Copy the values from one vec2 to another\n *\n * @param {vec2} out the receiving vector\n * @param {vec2} a the source vector\n * @returns {vec2} out\n */\n\nfunction copy$5(out, a) {\n  out[0] = a[0];\n  out[1] = a[1];\n  return out;\n}\n/**\n * Set the components of a vec2 to the given values\n *\n * @param {vec2} out the receiving vector\n * @param {Number} x X component\n * @param {Number} y Y component\n * @returns {vec2} out\n */\n\nfunction set$5(out, x, y) {\n  out[0] = x;\n  out[1] = y;\n  return out;\n}\n/**\n * Adds two vec2's\n *\n * @param {vec2} out the receiving vector\n * @param {vec2} a the first operand\n * @param {vec2} b the second operand\n * @returns {vec2} out\n */\n\nfunction add$1(out, a, b) {\n  out[0] = a[0] + b[0];\n  out[1] = a[1] + b[1];\n  return out;\n}\n/**\n * Subtracts vector b from vector a\n *\n * @param {vec2} out the receiving vector\n * @param {vec2} a the first operand\n * @param {vec2} b the second operand\n * @returns {vec2} out\n */\n\nfunction subtract$1(out, a, b) {\n  out[0] = a[0] - b[0];\n  out[1] = a[1] - b[1];\n  return out;\n}\n/**\n * Multiplies two vec2's\n *\n * @param {vec2} out the receiving vector\n * @param {vec2} a the first operand\n * @param {vec2} b the second operand\n * @returns {vec2} out\n */\n\nfunction multiply$4(out, a, b) {\n  out[0] = a[0] * b[0];\n  out[1] = a[1] * b[1];\n  return out;\n}\n/**\n * Divides two vec2's\n *\n * @param {vec2} out the receiving vector\n * @param {vec2} a the first operand\n * @param {vec2} b the second operand\n * @returns {vec2} out\n */\n\nfunction divide$1(out, a, b) {\n  out[0] = a[0] / b[0];\n  out[1] = a[1] / b[1];\n  return out;\n}\n/**\n * Scales a vec2 by a scalar number\n *\n * @param {vec2} out the receiving vector\n * @param {vec2} a the vector to scale\n * @param {Number} b amount to scale the vector by\n * @returns {vec2} out\n */\n\nfunction scale$3(out, a, b) {\n  out[0] = a[0] * b;\n  out[1] = a[1] * b;\n  return out;\n}\n/**\n * Calculates the euclidian distance between two vec2's\n *\n * @param {vec2} a the first operand\n * @param {vec2} b the second operand\n * @returns {Number} distance between a and b\n */\n\nfunction distance$1(a, b) {\n  var x = b[0] - a[0],\n      y = b[1] - a[1];\n  return Math.sqrt(x * x + y * y);\n}\n/**\n * Calculates the squared euclidian distance between two vec2's\n *\n * @param {vec2} a the first operand\n * @param {vec2} b the second operand\n * @returns {Number} squared distance between a and b\n */\n\nfunction squaredDistance$1(a, b) {\n  var x = b[0] - a[0],\n      y = b[1] - a[1];\n  return x * x + y * y;\n}\n/**\n * Calculates the length of a vec2\n *\n * @param {vec2} a vector to calculate length of\n * @returns {Number} length of a\n */\n\nfunction length$1(a) {\n  var x = a[0],\n      y = a[1];\n  return Math.sqrt(x * x + y * y);\n}\n/**\n * Calculates the squared length of a vec2\n *\n * @param {vec2} a vector to calculate squared length of\n * @returns {Number} squared length of a\n */\n\nfunction squaredLength$1(a) {\n  var x = a[0],\n      y = a[1];\n  return x * x + y * y;\n}\n/**\n * Negates the components of a vec2\n *\n * @param {vec2} out the receiving vector\n * @param {vec2} a vector to negate\n * @returns {vec2} out\n */\n\nfunction negate$1(out, a) {\n  out[0] = -a[0];\n  out[1] = -a[1];\n  return out;\n}\n/**\n * Returns the inverse of the components of a vec2\n *\n * @param {vec2} out the receiving vector\n * @param {vec2} a vector to invert\n * @returns {vec2} out\n */\n\nfunction inverse$1(out, a) {\n  out[0] = 1.0 / a[0];\n  out[1] = 1.0 / a[1];\n  return out;\n}\n/**\n * Normalize a vec2\n *\n * @param {vec2} out the receiving vector\n * @param {vec2} a vector to normalize\n * @returns {vec2} out\n */\n\nfunction normalize$3(out, a) {\n  var x = a[0],\n      y = a[1];\n  var len = x * x + y * y;\n\n  if (len > 0) {\n    //TODO: evaluate use of glm_invsqrt here?\n    len = 1 / Math.sqrt(len);\n  }\n\n  out[0] = a[0] * len;\n  out[1] = a[1] * len;\n  return out;\n}\n/**\n * Calculates the dot product of two vec2's\n *\n * @param {vec2} a the first operand\n * @param {vec2} b the second operand\n * @returns {Number} dot product of a and b\n */\n\nfunction dot$3(a, b) {\n  return a[0] * b[0] + a[1] * b[1];\n}\n/**\n * Computes the cross product of two vec2's\n * Note that the cross product returns a scalar\n *\n * @param {vec2} a the first operand\n * @param {vec2} b the second operand\n * @returns {Number} cross product of a and b\n */\n\nfunction cross$1(a, b) {\n  return a[0] * b[1] - a[1] * b[0];\n}\n/**\n * Performs a linear interpolation between two vec2's\n *\n * @param {vec2} out the receiving vector\n * @param {vec2} a the first operand\n * @param {vec2} b the second operand\n * @param {Number} t interpolation amount between the two inputs\n * @returns {vec2} out\n */\n\nfunction lerp$1(out, a, b, t) {\n  var ax = a[0],\n      ay = a[1];\n  out[0] = ax + t * (b[0] - ax);\n  out[1] = ay + t * (b[1] - ay);\n  return out;\n}\n/**\n * Transforms the vec2 with a mat3\n * 3rd vector component is implicitly '1'\n *\n * @param {vec2} out the receiving vector\n * @param {vec2} a the vector to transform\n * @param {mat3} m matrix to transform with\n * @returns {vec2} out\n */\n\nfunction transformMat3(out, a, m) {\n  var x = a[0],\n      y = a[1];\n  out[0] = m[0] * x + m[3] * y + m[6];\n  out[1] = m[1] * x + m[4] * y + m[7];\n  return out;\n}\n/**\n * Transforms the vec2 with a mat4\n * 3rd vector component is implicitly '0'\n * 4th vector component is implicitly '1'\n *\n * @param {vec2} out the receiving vector\n * @param {vec2} a the vector to transform\n * @param {mat4} m matrix to transform with\n * @returns {vec2} out\n */\n\nfunction transformMat4$1(out, a, m) {\n  let x = a[0];\n  let y = a[1];\n  out[0] = m[0] * x + m[4] * y + m[12];\n  out[1] = m[1] * x + m[5] * y + m[13];\n  return out;\n}\n/**\n * Returns whether or not the vectors exactly have the same elements in the same position (when compared with ===)\n *\n * @param {vec2} a The first vector.\n * @param {vec2} b The second vector.\n * @returns {Boolean} True if the vectors are equal, false otherwise.\n */\n\nfunction exactEquals$1(a, b) {\n  return a[0] === b[0] && a[1] === b[1];\n}\n\nclass Vec2 extends Array {\n  constructor(x = 0, y = x) {\n    super(x, y);\n    return this;\n  }\n\n  get x() {\n    return this[0];\n  }\n\n  get y() {\n    return this[1];\n  }\n\n  set x(v) {\n    this[0] = v;\n  }\n\n  set y(v) {\n    this[1] = v;\n  }\n\n  set(x, y = x) {\n    if (x.length) return this.copy(x);\n    set$5(this, x, y);\n    return this;\n  }\n\n  copy(v) {\n    copy$5(this, v);\n    return this;\n  }\n\n  add(va, vb) {\n    if (vb) add$1(this, va, vb);else add$1(this, this, va);\n    return this;\n  }\n\n  sub(va, vb) {\n    if (vb) subtract$1(this, va, vb);else subtract$1(this, this, va);\n    return this;\n  }\n\n  multiply(v) {\n    if (v.length) multiply$4(this, this, v);else scale$3(this, this, v);\n    return this;\n  }\n\n  divide(v) {\n    if (v.length) divide$1(this, this, v);else scale$3(this, this, 1 / v);\n    return this;\n  }\n\n  inverse(v = this) {\n    inverse$1(this, v);\n    return this;\n  } // Can't use 'length' as Array.prototype uses it\n\n\n  len() {\n    return length$1(this);\n  }\n\n  distance(v) {\n    if (v) return distance$1(this, v);else return length$1(this);\n  }\n\n  squaredLen() {\n    return this.squaredDistance();\n  }\n\n  squaredDistance(v) {\n    if (v) return squaredDistance$1(this, v);else return squaredLength$1(this);\n  }\n\n  negate(v = this) {\n    negate$1(this, v);\n    return this;\n  }\n\n  cross(va, vb) {\n    if (vb) return cross$1(va, vb);\n    return cross$1(this, va);\n  }\n\n  scale(v) {\n    scale$3(this, this, v);\n    return this;\n  }\n\n  normalize() {\n    normalize$3(this, this);\n    return this;\n  }\n\n  dot(v) {\n    return dot$3(this, v);\n  }\n\n  equals(v) {\n    return exactEquals$1(this, v);\n  }\n\n  applyMatrix3(mat3) {\n    transformMat3(this, this, mat3);\n    return this;\n  }\n\n  applyMatrix4(mat4) {\n    transformMat4$1(this, this, mat4);\n    return this;\n  }\n\n  lerp(v, a) {\n    lerp$1(this, this, v, a);\n  }\n\n  clone() {\n    return new Vec2(this[0], this[1]);\n  }\n\n  fromArray(a, o = 0) {\n    this[0] = a[o];\n    this[1] = a[o + 1];\n    return this;\n  }\n\n  toArray(a = [], o = 0) {\n    a[o] = this[0];\n    a[o + 1] = this[1];\n    return a;\n  }\n\n}\n\nclass Vec4 extends Array {\n  constructor(x = 0, y = x, z = x, w = x) {\n    super(x, y, z, w);\n    return this;\n  }\n\n  get x() {\n    return this[0];\n  }\n\n  get y() {\n    return this[1];\n  }\n\n  get z() {\n    return this[2];\n  }\n\n  get w() {\n    return this[3];\n  }\n\n  set x(v) {\n    this[0] = v;\n  }\n\n  set y(v) {\n    this[1] = v;\n  }\n\n  set z(v) {\n    this[2] = v;\n  }\n\n  set w(v) {\n    this[3] = v;\n  }\n\n  set(x, y, z, w) {\n    if (x.length) return this.copy(x);\n    set$2(this, x, y, z, w);\n    return this;\n  }\n\n  copy(v) {\n    copy$2(this, v);\n    return this;\n  }\n\n  normalize() {\n    normalize$1(this, this);\n    return this;\n  }\n\n  fromArray(a, o = 0) {\n    this[0] = a[o];\n    this[1] = a[o + 1];\n    this[2] = a[o + 2];\n    this[3] = a[o + 3];\n    return this;\n  }\n\n  toArray(a = [], o = 0) {\n    a[o] = this[0];\n    a[o + 1] = this[1];\n    a[o + 2] = this[2];\n    a[o + 3] = this[3];\n    return a;\n  }\n\n}\n\nclass Plane extends Geometry {\n  constructor(gl, {\n    width = 1,\n    height = 1,\n    widthSegments = 1,\n    heightSegments = 1,\n    attributes = {}\n  } = {}) {\n    const wSegs = widthSegments;\n    const hSegs = heightSegments; // Determine length of arrays\n\n    const num = (wSegs + 1) * (hSegs + 1);\n    const numIndices = wSegs * hSegs * 6; // Generate empty arrays once\n\n    const position = new Float32Array(num * 3);\n    const normal = new Float32Array(num * 3);\n    const uv = new Float32Array(num * 2);\n    const index = num > 65536 ? new Uint32Array(numIndices) : new Uint16Array(numIndices);\n    Plane.buildPlane(position, normal, uv, index, width, height, 0, wSegs, hSegs);\n    Object.assign(attributes, {\n      position: {\n        size: 3,\n        data: position\n      },\n      normal: {\n        size: 3,\n        data: normal\n      },\n      uv: {\n        size: 2,\n        data: uv\n      },\n      index: {\n        data: index\n      }\n    });\n    super(gl, attributes);\n  }\n\n  static buildPlane(position, normal, uv, index, width, height, depth, wSegs, hSegs, u = 0, v = 1, w = 2, uDir = 1, vDir = -1, i = 0, ii = 0) {\n    const io = i;\n    const segW = width / wSegs;\n    const segH = height / hSegs;\n\n    for (let iy = 0; iy <= hSegs; iy++) {\n      let y = iy * segH - height / 2;\n\n      for (let ix = 0; ix <= wSegs; ix++, i++) {\n        let x = ix * segW - width / 2;\n        position[i * 3 + u] = x * uDir;\n        position[i * 3 + v] = y * vDir;\n        position[i * 3 + w] = depth / 2;\n        normal[i * 3 + u] = 0;\n        normal[i * 3 + v] = 0;\n        normal[i * 3 + w] = depth >= 0 ? 1 : -1;\n        uv[i * 2] = ix / wSegs;\n        uv[i * 2 + 1] = 1 - iy / hSegs;\n        if (iy === hSegs || ix === wSegs) continue;\n        let a = io + ix + iy * (wSegs + 1);\n        let b = io + ix + (iy + 1) * (wSegs + 1);\n        let c = io + ix + (iy + 1) * (wSegs + 1) + 1;\n        let d = io + ix + iy * (wSegs + 1) + 1;\n        index[ii * 6] = a;\n        index[ii * 6 + 1] = b;\n        index[ii * 6 + 2] = d;\n        index[ii * 6 + 3] = b;\n        index[ii * 6 + 4] = c;\n        index[ii * 6 + 5] = d;\n        ii++;\n      }\n    }\n  }\n\n}\n\nclass Box extends Geometry {\n  constructor(gl, {\n    width = 1,\n    height = 1,\n    depth = 1,\n    widthSegments = 1,\n    heightSegments = 1,\n    depthSegments = 1,\n    attributes = {}\n  } = {}) {\n    const wSegs = widthSegments;\n    const hSegs = heightSegments;\n    const dSegs = depthSegments;\n    const num = (wSegs + 1) * (hSegs + 1) * 2 + (wSegs + 1) * (dSegs + 1) * 2 + (hSegs + 1) * (dSegs + 1) * 2;\n    const numIndices = (wSegs * hSegs * 2 + wSegs * dSegs * 2 + hSegs * dSegs * 2) * 6;\n    const position = new Float32Array(num * 3);\n    const normal = new Float32Array(num * 3);\n    const uv = new Float32Array(num * 2);\n    const index = num > 65536 ? new Uint32Array(numIndices) : new Uint16Array(numIndices);\n    let i = 0;\n    let ii = 0; // left, right\n\n    Plane.buildPlane(position, normal, uv, index, depth, height, width, dSegs, hSegs, 2, 1, 0, -1, -1, i, ii);\n    Plane.buildPlane(position, normal, uv, index, depth, height, -width, dSegs, hSegs, 2, 1, 0, 1, -1, i += (dSegs + 1) * (hSegs + 1), ii += dSegs * hSegs); // top, bottom\n\n    Plane.buildPlane(position, normal, uv, index, width, depth, height, dSegs, hSegs, 0, 2, 1, 1, 1, i += (dSegs + 1) * (hSegs + 1), ii += dSegs * hSegs);\n    Plane.buildPlane(position, normal, uv, index, width, depth, -height, dSegs, hSegs, 0, 2, 1, 1, -1, i += (wSegs + 1) * (dSegs + 1), ii += wSegs * dSegs); // front, back\n\n    Plane.buildPlane(position, normal, uv, index, width, height, -depth, wSegs, hSegs, 0, 1, 2, -1, -1, i += (wSegs + 1) * (dSegs + 1), ii += wSegs * dSegs);\n    Plane.buildPlane(position, normal, uv, index, width, height, depth, wSegs, hSegs, 0, 1, 2, 1, -1, i += (wSegs + 1) * (hSegs + 1), ii += wSegs * hSegs);\n    Object.assign(attributes, {\n      position: {\n        size: 3,\n        data: position\n      },\n      normal: {\n        size: 3,\n        data: normal\n      },\n      uv: {\n        size: 2,\n        data: uv\n      },\n      index: {\n        data: index\n      }\n    });\n    super(gl, attributes);\n  }\n\n}\n\nclass Sphere extends Geometry {\n  constructor(gl, {\n    radius = 0.5,\n    widthSegments = 16,\n    heightSegments = Math.ceil(widthSegments * 0.5),\n    phiStart = 0,\n    phiLength = Math.PI * 2,\n    thetaStart = 0,\n    thetaLength = Math.PI,\n    attributes = {}\n  } = {}) {\n    const wSegs = widthSegments;\n    const hSegs = heightSegments;\n    const pStart = phiStart;\n    const pLength = phiLength;\n    const tStart = thetaStart;\n    const tLength = thetaLength;\n    const num = (wSegs + 1) * (hSegs + 1);\n    const numIndices = wSegs * hSegs * 6;\n    const position = new Float32Array(num * 3);\n    const normal = new Float32Array(num * 3);\n    const uv = new Float32Array(num * 2);\n    const index = num > 65536 ? new Uint32Array(numIndices) : new Uint16Array(numIndices);\n    let i = 0;\n    let iv = 0;\n    let ii = 0;\n    let te = tStart + tLength;\n    const grid = [];\n    let n = new Vec3();\n\n    for (let iy = 0; iy <= hSegs; iy++) {\n      let vRow = [];\n      let v = iy / hSegs;\n\n      for (let ix = 0; ix <= wSegs; ix++, i++) {\n        let u = ix / wSegs;\n        let x = -radius * Math.cos(pStart + u * pLength) * Math.sin(tStart + v * tLength);\n        let y = radius * Math.cos(tStart + v * tLength);\n        let z = radius * Math.sin(pStart + u * pLength) * Math.sin(tStart + v * tLength);\n        position[i * 3] = x;\n        position[i * 3 + 1] = y;\n        position[i * 3 + 2] = z;\n        n.set(x, y, z).normalize();\n        normal[i * 3] = n.x;\n        normal[i * 3 + 1] = n.y;\n        normal[i * 3 + 2] = n.z;\n        uv[i * 2] = u;\n        uv[i * 2 + 1] = 1 - v;\n        vRow.push(iv++);\n      }\n\n      grid.push(vRow);\n    }\n\n    for (let iy = 0; iy < hSegs; iy++) {\n      for (let ix = 0; ix < wSegs; ix++) {\n        let a = grid[iy][ix + 1];\n        let b = grid[iy][ix];\n        let c = grid[iy + 1][ix];\n        let d = grid[iy + 1][ix + 1];\n\n        if (iy !== 0 || tStart > 0) {\n          index[ii * 3] = a;\n          index[ii * 3 + 1] = b;\n          index[ii * 3 + 2] = d;\n          ii++;\n        }\n\n        if (iy !== hSegs - 1 || te < Math.PI) {\n          index[ii * 3] = b;\n          index[ii * 3 + 1] = c;\n          index[ii * 3 + 2] = d;\n          ii++;\n        }\n      }\n    }\n\n    Object.assign(attributes, {\n      position: {\n        size: 3,\n        data: position\n      },\n      normal: {\n        size: 3,\n        data: normal\n      },\n      uv: {\n        size: 2,\n        data: uv\n      },\n      index: {\n        data: index\n      }\n    });\n    super(gl, attributes);\n  }\n\n}\n\nclass Cylinder extends Geometry {\n  constructor(gl, {\n    radiusTop = 0.5,\n    radiusBottom = 0.5,\n    height = 1,\n    radialSegments = 8,\n    heightSegments = 1,\n    openEnded = false,\n    thetaStart = 0,\n    thetaLength = Math.PI * 2,\n    attributes = {}\n  } = {}) {\n    const rSegs = radialSegments;\n    const hSegs = heightSegments;\n    const tStart = thetaStart;\n    const tLength = thetaLength;\n    const numCaps = openEnded ? 0 : radiusBottom && radiusTop ? 2 : 1;\n    const num = (rSegs + 1) * (hSegs + 1 + numCaps) + numCaps;\n    const numIndices = rSegs * hSegs * 6 + numCaps * rSegs * 3;\n    const position = new Float32Array(num * 3);\n    const normal = new Float32Array(num * 3);\n    const uv = new Float32Array(num * 2);\n    const index = num > 65536 ? new Uint32Array(numIndices) : new Uint16Array(numIndices);\n    let i = 0;\n    let ii = 0;\n    const indexArray = [];\n    addHeight();\n\n    if (!openEnded) {\n      if (radiusTop) addCap(true);\n      if (radiusBottom) addCap(false);\n    }\n\n    function addHeight() {\n      let x, y;\n      const n = new Vec3();\n      const slope = (radiusBottom - radiusTop) / height;\n\n      for (y = 0; y <= hSegs; y++) {\n        const indexRow = [];\n        const v = y / hSegs;\n        const r = v * (radiusBottom - radiusTop) + radiusTop;\n\n        for (x = 0; x <= rSegs; x++) {\n          const u = x / rSegs;\n          const theta = u * tLength + tStart;\n          const sinTheta = Math.sin(theta);\n          const cosTheta = Math.cos(theta);\n          position.set([r * sinTheta, (0.5 - v) * height, r * cosTheta], i * 3);\n          n.set(sinTheta, slope, cosTheta).normalize();\n          normal.set([n.x, n.y, n.z], i * 3);\n          uv.set([u, 1 - v], i * 2);\n          indexRow.push(i++);\n        }\n\n        indexArray.push(indexRow);\n      }\n\n      for (x = 0; x < rSegs; x++) {\n        for (y = 0; y < hSegs; y++) {\n          const a = indexArray[y][x];\n          const b = indexArray[y + 1][x];\n          const c = indexArray[y + 1][x + 1];\n          const d = indexArray[y][x + 1];\n          index.set([a, b, d, b, c, d], ii * 3);\n          ii += 2;\n        }\n      }\n    }\n\n    function addCap(isTop) {\n      let x;\n      const r = isTop === true ? radiusTop : radiusBottom;\n      const sign = isTop === true ? 1 : -1;\n      const centerIndex = i;\n      position.set([0, 0.5 * height * sign, 0], i * 3);\n      normal.set([0, sign, 0], i * 3);\n      uv.set([0.5, 0.5], i * 2);\n      i++;\n\n      for (x = 0; x <= rSegs; x++) {\n        const u = x / rSegs;\n        const theta = u * tLength + tStart;\n        const cosTheta = Math.cos(theta);\n        const sinTheta = Math.sin(theta);\n        position.set([r * sinTheta, 0.5 * height * sign, r * cosTheta], i * 3);\n        normal.set([0, sign, 0], i * 3);\n        uv.set([cosTheta * 0.5 + 0.5, sinTheta * 0.5 * sign + 0.5], i * 2);\n        i++;\n      }\n\n      for (x = 0; x < rSegs; x++) {\n        const j = centerIndex + x + 1;\n\n        if (isTop) {\n          index.set([j, j + 1, centerIndex], ii * 3);\n        } else {\n          index.set([j + 1, j, centerIndex], ii * 3);\n        }\n\n        ii++;\n      }\n    }\n\n    Object.assign(attributes, {\n      position: {\n        size: 3,\n        data: position\n      },\n      normal: {\n        size: 3,\n        data: normal\n      },\n      uv: {\n        size: 2,\n        data: uv\n      },\n      index: {\n        data: index\n      }\n    });\n    super(gl, attributes);\n  }\n\n}\n\nclass Triangle extends Geometry {\n  constructor(gl, {\n    attributes = {}\n  } = {}) {\n    //         position                uv\n    //      (-1, 3)                  (0, 2)\n    //         |\\                      |\\\n    //         |__\\(1, 1)              |__\\(1, 1)\n    //         |__|_\\                  |__|_\\\n    //   (-1, -1)   (3, -1)        (0, 0)   (2, 0)\n    Object.assign(attributes, {\n      position: {\n        size: 2,\n        data: new Float32Array([-1, -1, 3, -1, -1, 3])\n      },\n      uv: {\n        size: 2,\n        data: new Float32Array([0, 0, 2, 0, 0, 2])\n      }\n    });\n    super(gl, attributes);\n  }\n\n}\n\n// https://github.com/mrdoob/three.js/blob/master/src/geometries/TorusGeometry.js\nclass Torus extends Geometry {\n  constructor(gl, {\n    radius = 0.5,\n    tube = 0.2,\n    radialSegments = 8,\n    tubularSegments = 6,\n    arc = Math.PI * 2,\n    attributes = {}\n  } = {}) {\n    const num = (radialSegments + 1) * (tubularSegments + 1);\n    const numIndices = radialSegments * tubularSegments * 6;\n    const vertices = new Float32Array(num * 3);\n    const normals = new Float32Array(num * 3);\n    const uvs = new Float32Array(num * 2);\n    const indices = num > 65536 ? new Uint32Array(numIndices) : new Uint16Array(numIndices);\n    const center = new Vec3();\n    const vertex = new Vec3();\n    const normal = new Vec3(); // generate vertices, normals and uvs\n\n    let idx = 0;\n\n    for (let j = 0; j <= radialSegments; j++) {\n      for (let i = 0; i <= tubularSegments; i++, idx++) {\n        const u = i / tubularSegments * arc;\n        const v = j / radialSegments * Math.PI * 2; // vertex\n\n        vertex.x = (radius + tube * Math.cos(v)) * Math.cos(u);\n        vertex.y = (radius + tube * Math.cos(v)) * Math.sin(u);\n        vertex.z = tube * Math.sin(v);\n        vertices.set([vertex.x, vertex.y, vertex.z], idx * 3); // normal\n\n        center.x = radius * Math.cos(u);\n        center.y = radius * Math.sin(u);\n        normal.sub(vertex, center).normalize();\n        normals.set([normal.x, normal.y, normal.z], idx * 3); // uv\n\n        uvs.set([i / tubularSegments, j / radialSegments], idx * 2);\n      }\n    } // generate indices\n\n\n    idx = 0;\n\n    for (let j = 1; j <= radialSegments; j++) {\n      for (let i = 1; i <= tubularSegments; i++, idx++) {\n        // indices\n        const a = (tubularSegments + 1) * j + i - 1;\n        const b = (tubularSegments + 1) * (j - 1) + i - 1;\n        const c = (tubularSegments + 1) * (j - 1) + i;\n        const d = (tubularSegments + 1) * j + i; // faces\n\n        indices.set([a, b, d, b, c, d], idx * 6);\n      }\n    }\n\n    Object.assign(attributes, {\n      position: {\n        size: 3,\n        data: vertices\n      },\n      normal: {\n        size: 3,\n        data: normals\n      },\n      uv: {\n        size: 2,\n        data: uvs\n      },\n      index: {\n        data: indices\n      }\n    });\n    super(gl, attributes);\n  }\n\n}\n\n// Based from ThreeJS' OrbitControls class, rewritten using es6 with some additions and subtractions.\nconst STATE = {\n  NONE: -1,\n  ROTATE: 0,\n  DOLLY: 1,\n  PAN: 2,\n  DOLLY_PAN: 3\n};\nconst tempVec3$2 = new Vec3();\nconst tempVec2a = new Vec2();\nconst tempVec2b = new Vec2();\nfunction Orbit(object, // TODO: fov property only be used in pan()\n{\n  element = document.body,\n  enabled = true,\n  target = new Vec3(),\n  ease = 0.25,\n  inertia = 0.85,\n  enableRotate = true,\n  rotateSpeed = 0.1,\n  autoRotate = false,\n  autoRotateSpeed = 1.0,\n  enableZoom = true,\n  zoomSpeed = 1,\n  enablePan = true,\n  panSpeed = 0.1,\n  minPolarAngle = 0,\n  maxPolarAngle = Math.PI,\n  minAzimuthAngle = -Infinity,\n  maxAzimuthAngle = Infinity,\n  minDistance = 0,\n  maxDistance = Infinity\n} = {}) {\n  this.enabled = enabled;\n  this.target = target; // Catch attempts to disable - set to 1 so has no effect\n\n  ease = ease || 1;\n  inertia = inertia || 0;\n  this.minDistance = minDistance;\n  this.maxDistance = maxDistance; // current position in sphericalTarget coordinates\n\n  const sphericalDelta = {\n    radius: 1,\n    phi: 0,\n    theta: 0\n  };\n  const sphericalTarget = {\n    radius: 1,\n    phi: 0,\n    theta: 0\n  };\n  const spherical = {\n    radius: 1,\n    phi: 0,\n    theta: 0\n  };\n  const panDelta = new Vec3(); // Grab initial position values\n\n  const offset = new Vec3();\n  offset.copy(object.position).sub(this.target);\n  spherical.radius = sphericalTarget.radius = offset.distance();\n  spherical.theta = sphericalTarget.theta = Math.atan2(offset.x, offset.z);\n  spherical.phi = sphericalTarget.phi = Math.acos(Math.min(Math.max(offset.y / sphericalTarget.radius, -1), 1));\n  this.offset = offset;\n\n  this.update = () => {\n    if (autoRotate) {\n      handleAutoRotate();\n    } // apply delta\n\n\n    sphericalTarget.radius *= sphericalDelta.radius;\n    sphericalTarget.theta += sphericalDelta.theta;\n    sphericalTarget.phi += sphericalDelta.phi; // apply boundaries\n\n    sphericalTarget.theta = Math.max(minAzimuthAngle, Math.min(maxAzimuthAngle, sphericalTarget.theta));\n    sphericalTarget.phi = Math.max(minPolarAngle, Math.min(maxPolarAngle, sphericalTarget.phi));\n    sphericalTarget.radius = Math.max(this.minDistance, Math.min(this.maxDistance, sphericalTarget.radius)); // ease values\n\n    spherical.phi += (sphericalTarget.phi - spherical.phi) * ease;\n    spherical.theta += (sphericalTarget.theta - spherical.theta) * ease;\n    spherical.radius += (sphericalTarget.radius - spherical.radius) * ease; // apply pan to target. As offset is relative to target, it also shifts\n\n    this.target.add(panDelta); // apply rotation to offset\n\n    let sinPhiRadius = spherical.radius * Math.sin(Math.max(0.000001, spherical.phi));\n    offset.x = sinPhiRadius * Math.sin(spherical.theta);\n    offset.y = spherical.radius * Math.cos(spherical.phi);\n    offset.z = sinPhiRadius * Math.cos(spherical.theta); // Apply updated values to object\n\n    object.position.copy(this.target).add(offset);\n    object.lookAt(this.target); // Apply inertia to values\n\n    sphericalDelta.theta *= inertia;\n    sphericalDelta.phi *= inertia;\n    panDelta.multiply(inertia); // Reset scale every frame to avoid applying scale multiple times\n\n    sphericalDelta.radius = 1;\n  }; // Updates internals with new position\n\n\n  this.forcePosition = () => {\n    offset.copy(object.position).sub(this.target);\n    spherical.radius = sphericalTarget.radius = offset.distance();\n    spherical.theta = sphericalTarget.theta = Math.atan2(offset.x, offset.z);\n    spherical.phi = sphericalTarget.phi = Math.acos(Math.min(Math.max(offset.y / sphericalTarget.radius, -1), 1));\n    object.lookAt(this.target);\n  }; // Everything below here just updates panDelta and sphericalDelta\n  // Using those two objects' values, the orbit is calculated\n\n\n  const rotateStart = new Vec2();\n  const panStart = new Vec2();\n  const dollyStart = new Vec2();\n  let state = STATE.NONE;\n  this.mouseButtons = {\n    ORBIT: 0,\n    ZOOM: 1,\n    PAN: 2\n  };\n\n  function getZoomScale() {\n    return Math.pow(0.95, zoomSpeed);\n  }\n\n  function panLeft(distance, m) {\n    tempVec3$2.set(m[0], m[1], m[2]);\n    tempVec3$2.multiply(-distance);\n    panDelta.add(tempVec3$2);\n  }\n\n  function panUp(distance, m) {\n    tempVec3$2.set(m[4], m[5], m[6]);\n    tempVec3$2.multiply(distance);\n    panDelta.add(tempVec3$2);\n  }\n\n  const pan = (deltaX, deltaY) => {\n    // let el = element === document ? document.body : element;\n    tempVec3$2.copy(object.position).sub(this.target);\n    let targetDistance = tempVec3$2.distance();\n    targetDistance *= Math.tan((object.fov || 45) / 2 * Math.PI / 180.0);\n    panLeft(2 * deltaX * targetDistance / element.clientHeight, object.matrix);\n    panUp(2 * deltaY * targetDistance / element.clientHeight, object.matrix);\n  };\n\n  function dolly(dollyScale) {\n    sphericalDelta.radius /= dollyScale;\n  }\n\n  function handleAutoRotate() {\n    const angle = 2 * Math.PI / 60 / 60 * autoRotateSpeed;\n    sphericalDelta.theta -= angle;\n  }\n\n  function handleMoveRotate(x, y) {\n    tempVec2a.set(x, y);\n    tempVec2b.sub(tempVec2a, rotateStart).multiply(rotateSpeed); // let el = element === document ? document.body : element;\n\n    sphericalDelta.theta -= 2 * Math.PI * tempVec2b.x / element.clientHeight;\n    sphericalDelta.phi -= 2 * Math.PI * tempVec2b.y / element.clientHeight;\n    rotateStart.copy(tempVec2a);\n  }\n\n  function handleMouseMoveDolly(e) {\n    tempVec2a.set(e.clientX, e.clientY);\n    tempVec2b.sub(tempVec2a, dollyStart);\n\n    if (tempVec2b.y > 0) {\n      dolly(getZoomScale());\n    } else if (tempVec2b.y < 0) {\n      dolly(1 / getZoomScale());\n    }\n\n    dollyStart.copy(tempVec2a);\n  }\n\n  function handleMovePan(x, y) {\n    tempVec2a.set(x, y);\n    tempVec2b.sub(tempVec2a, panStart).multiply(panSpeed);\n    pan(tempVec2b.x, tempVec2b.y);\n    panStart.copy(tempVec2a);\n  }\n\n  function handleTouchStartDollyPan(e) {\n    if (enableZoom) {\n      let dx = e.touches[0].pageX - e.touches[1].pageX;\n      let dy = e.touches[0].pageY - e.touches[1].pageY;\n      let distance = Math.sqrt(dx * dx + dy * dy);\n      dollyStart.set(0, distance);\n    }\n\n    if (enablePan) {\n      let x = 0.5 * (e.touches[0].pageX + e.touches[1].pageX);\n      let y = 0.5 * (e.touches[0].pageY + e.touches[1].pageY);\n      panStart.set(x, y);\n    }\n  }\n\n  function handleTouchMoveDollyPan(e) {\n    if (enableZoom) {\n      let dx = e.touches[0].pageX - e.touches[1].pageX;\n      let dy = e.touches[0].pageY - e.touches[1].pageY;\n      let distance = Math.sqrt(dx * dx + dy * dy);\n      tempVec2a.set(0, distance);\n      tempVec2b.set(0, Math.pow(tempVec2a.y / dollyStart.y, zoomSpeed));\n      dolly(tempVec2b.y);\n      dollyStart.copy(tempVec2a);\n    }\n\n    if (enablePan) {\n      let x = 0.5 * (e.touches[0].pageX + e.touches[1].pageX);\n      let y = 0.5 * (e.touches[0].pageY + e.touches[1].pageY);\n      handleMovePan(x, y);\n    }\n  }\n\n  const onMouseDown = e => {\n    if (!this.enabled) return;\n\n    switch (e.button) {\n      case this.mouseButtons.ORBIT:\n        if (enableRotate === false) return;\n        rotateStart.set(e.clientX, e.clientY);\n        state = STATE.ROTATE;\n        break;\n\n      case this.mouseButtons.ZOOM:\n        if (enableZoom === false) return;\n        dollyStart.set(e.clientX, e.clientY);\n        state = STATE.DOLLY;\n        break;\n\n      case this.mouseButtons.PAN:\n        if (enablePan === false) return;\n        panStart.set(e.clientX, e.clientY);\n        state = STATE.PAN;\n        break;\n    }\n\n    if (state !== STATE.NONE) {\n      window.addEventListener('mousemove', onMouseMove, false);\n      window.addEventListener('mouseup', onMouseUp, false);\n    }\n  };\n\n  const onMouseMove = e => {\n    if (!this.enabled) return;\n\n    switch (state) {\n      case STATE.ROTATE:\n        if (enableRotate === false) return;\n        handleMoveRotate(e.clientX, e.clientY);\n        break;\n\n      case STATE.DOLLY:\n        if (enableZoom === false) return;\n        handleMouseMoveDolly(e);\n        break;\n\n      case STATE.PAN:\n        if (enablePan === false) return;\n        handleMovePan(e.clientX, e.clientY);\n        break;\n    }\n  };\n\n  const onMouseUp = () => {\n    window.removeEventListener('mousemove', onMouseMove, false);\n    window.removeEventListener('mouseup', onMouseUp, false);\n    state = STATE.NONE;\n  };\n\n  const onMouseWheel = e => {\n    if (!this.enabled || !enableZoom || state !== STATE.NONE && state !== STATE.ROTATE) return;\n    e.stopPropagation();\n    e.preventDefault();\n\n    if (e.deltaY < 0) {\n      dolly(1 / getZoomScale());\n    } else if (e.deltaY > 0) {\n      dolly(getZoomScale());\n    }\n  };\n\n  const onTouchStart = e => {\n    if (!this.enabled) return;\n    e.preventDefault();\n\n    switch (e.touches.length) {\n      case 1:\n        if (enableRotate === false) return;\n        rotateStart.set(e.touches[0].pageX, e.touches[0].pageY);\n        state = STATE.ROTATE;\n        break;\n\n      case 2:\n        if (enableZoom === false && enablePan === false) return;\n        handleTouchStartDollyPan(e);\n        state = STATE.DOLLY_PAN;\n        break;\n\n      default:\n        state = STATE.NONE;\n    }\n  };\n\n  const onTouchMove = e => {\n    if (!this.enabled) return;\n    e.preventDefault();\n    e.stopPropagation();\n\n    switch (e.touches.length) {\n      case 1:\n        if (enableRotate === false) return;\n        handleMoveRotate(e.touches[0].pageX, e.touches[0].pageY);\n        break;\n\n      case 2:\n        if (enableZoom === false && enablePan === false) return;\n        handleTouchMoveDollyPan(e);\n        break;\n\n      default:\n        state = STATE.NONE;\n    }\n  };\n\n  const onTouchEnd = () => {\n    if (!this.enabled) return;\n    state = STATE.NONE;\n  };\n\n  const onContextMenu = e => {\n    if (!this.enabled) return;\n    e.preventDefault();\n  };\n\n  function addHandlers() {\n    element.addEventListener('contextmenu', onContextMenu, false);\n    element.addEventListener('mousedown', onMouseDown, false);\n    element.addEventListener('wheel', onMouseWheel, {\n      passive: false\n    });\n    element.addEventListener('touchstart', onTouchStart, {\n      passive: false\n    });\n    element.addEventListener('touchend', onTouchEnd, false);\n    element.addEventListener('touchmove', onTouchMove, {\n      passive: false\n    });\n  }\n\n  this.remove = function () {\n    element.removeEventListener('contextmenu', onContextMenu);\n    element.removeEventListener('mousedown', onMouseDown);\n    element.removeEventListener('wheel', onMouseWheel);\n    element.removeEventListener('touchstart', onTouchStart);\n    element.removeEventListener('touchend', onTouchEnd);\n    element.removeEventListener('touchmove', onTouchMove);\n    window.removeEventListener('mousemove', onMouseMove);\n    window.removeEventListener('mouseup', onMouseUp);\n  };\n\n  addHandlers();\n}\n\n// TODO: barycentric code shouldn't be here, but where?\nconst tempVec2a$1 = new Vec2();\nconst tempVec2b$1 = new Vec2();\nconst tempVec2c = new Vec2();\nconst tempVec3a$1 = new Vec3();\nconst tempVec3b$1 = new Vec3();\nconst tempVec3c = new Vec3();\nconst tempVec3d = new Vec3();\nconst tempVec3e = new Vec3();\nconst tempVec3f = new Vec3();\nconst tempVec3g = new Vec3();\nconst tempVec3h = new Vec3();\nconst tempVec3i = new Vec3();\nconst tempVec3j = new Vec3();\nconst tempVec3k = new Vec3();\nconst tempMat4$1 = new Mat4();\nclass Raycast {\n  constructor(gl) {\n    this.gl = void 0;\n    this.origin = void 0;\n    this.direction = void 0;\n    this.gl = gl;\n    this.origin = new Vec3();\n    this.direction = new Vec3();\n  } // Set ray from mouse unprojection\n\n\n  castMouse(camera, mouse = [0, 0]) {\n    if (camera.type === 'orthographic') {\n      // Set origin\n      // Since camera is orthographic, origin is not the camera position\n      const {\n        left,\n        right,\n        bottom,\n        top,\n        zoom\n      } = camera;\n      const x = left / zoom + (right - left) / zoom * (mouse[0] * 0.5 + 0.5);\n      const y = bottom / zoom + (top - bottom) / zoom * (mouse[1] * 0.5 + 0.5);\n      this.origin.set(x, y, 0);\n      this.origin.applyMatrix4(camera.worldMatrix); // Set direction\n      // https://community.khronos.org/t/get-direction-from-transformation-matrix-or-quat/65502/2\n\n      this.direction.x = -camera.worldMatrix[8];\n      this.direction.y = -camera.worldMatrix[9];\n      this.direction.z = -camera.worldMatrix[10];\n    } else {\n      // Set origin\n      camera.worldMatrix.getTranslation(this.origin); // Set direction\n\n      this.direction.set(mouse[0], mouse[1], 0.5);\n      camera.unproject(this.direction);\n      this.direction.sub(this.origin).normalize();\n    }\n  }\n\n  intersectBounds(meshes, {\n    maxDistance,\n    output = []\n  } = {}) {\n    if (!Array.isArray(meshes)) meshes = [meshes];\n    const invWorldMat4 = tempMat4$1;\n    const origin = tempVec3a$1;\n    const direction = tempVec3b$1;\n    const hits = output;\n    hits.length = 0;\n    meshes.forEach(mesh => {\n      // Create bounds\n      if (!mesh.geometry.bounds || mesh.geometry.bounds.radius === Infinity) mesh.geometry.computeBoundingSphere();\n      const bounds = mesh.geometry.bounds;\n      invWorldMat4.inverse(mesh.worldMatrix); // Get max distance locally\n\n      let localMaxDistance;\n\n      if (maxDistance) {\n        direction.copy(this.direction).scaleRotateMatrix4(invWorldMat4);\n        localMaxDistance = maxDistance * direction.len();\n      } // Take world space ray and make it object space to align with bounding box\n\n\n      origin.copy(this.origin).applyMatrix4(invWorldMat4);\n      direction.copy(this.direction).transformDirection(invWorldMat4); // Break out early if bounds too far away from origin\n\n      if (maxDistance) {\n        if (origin.distance(bounds.center) - bounds.radius > localMaxDistance) return;\n      }\n\n      let localDistance = 0; // Check origin isn't inside bounds before testing intersection\n\n      if (mesh.geometry.raycast === 'sphere') {\n        if (origin.distance(bounds.center) > bounds.radius) {\n          localDistance = this.intersectSphere(bounds, origin, direction);\n          if (!localDistance) return;\n        }\n      } else {\n        if (origin.x < bounds.min.x || origin.x > bounds.max.x || origin.y < bounds.min.y || origin.y > bounds.max.y || origin.z < bounds.min.z || origin.z > bounds.max.z) {\n          localDistance = this.intersectBox(bounds, origin, direction);\n          if (!localDistance) return;\n        }\n      }\n\n      if (maxDistance && localDistance > localMaxDistance) return; // Create object on mesh to avoid generating lots of objects\n\n      if (!mesh.hit) mesh.hit = {\n        localPoint: new Vec3(),\n        point: new Vec3()\n      };\n      mesh.hit.localPoint.copy(direction).multiply(localDistance).add(origin);\n      mesh.hit.point.copy(mesh.hit.localPoint).applyMatrix4(mesh.worldMatrix);\n      mesh.hit.distance = mesh.hit.point.distance(this.origin);\n      hits.push(mesh);\n    });\n    hits.sort((a, b) => a.hit.distance - b.hit.distance);\n    return hits;\n  }\n\n  intersectMeshes(meshes, {\n    cullFace = true,\n    maxDistance = null,\n    includeUV = true,\n    includeNormal = true,\n    output = []\n  } = {}) {\n    // Test bounds first before testing geometry\n    const hits = this.intersectBounds(meshes, {\n      maxDistance,\n      output\n    });\n    if (!hits.length) return hits;\n    const invWorldMat4 = tempMat4$1;\n    const origin = tempVec3a$1;\n    const direction = tempVec3b$1;\n    const a = tempVec3c;\n    const b = tempVec3d;\n    const c = tempVec3e;\n    const closestFaceNormal = tempVec3f;\n    const faceNormal = tempVec3g;\n    const barycoord = tempVec3h;\n    const uvA = tempVec2a$1;\n    const uvB = tempVec2b$1;\n    const uvC = tempVec2c;\n\n    for (let i = hits.length - 1; i >= 0; i--) {\n      const mesh = hits[i];\n      invWorldMat4.inverse(mesh.worldMatrix); // Get max distance locally\n\n      let localMaxDistance;\n\n      if (maxDistance) {\n        direction.copy(this.direction).scaleRotateMatrix4(invWorldMat4);\n        localMaxDistance = maxDistance * direction.len();\n      } // Take world space ray and make it object space to align with bounding box\n\n\n      origin.copy(this.origin).applyMatrix4(invWorldMat4);\n      direction.copy(this.direction).transformDirection(invWorldMat4);\n      let localDistance = 0;\n      let closestA, closestB, closestC;\n      const geometry = mesh.geometry;\n      const attributes = geometry.attributes;\n      const index = attributes.index;\n      const start = Math.max(0, geometry.drawRange.start);\n      const end = Math.min(index ? index.count : attributes.position.count, geometry.drawRange.start + geometry.drawRange.count);\n\n      for (let j = start; j < end; j += 3) {\n        // Position attribute indices for each triangle\n        const ai = index ? index.data[j] : j;\n        const bi = index ? index.data[j + 1] : j + 1;\n        const ci = index ? index.data[j + 2] : j + 2;\n        a.fromArray(attributes.position.data, ai * 3);\n        b.fromArray(attributes.position.data, bi * 3);\n        c.fromArray(attributes.position.data, ci * 3);\n        const distance = this.intersectTriangle(a, b, c, cullFace, origin, direction, faceNormal);\n        if (!distance) continue; // Too far away\n\n        if (maxDistance && distance > localMaxDistance) continue;\n\n        if (!localDistance || distance < localDistance) {\n          localDistance = distance;\n          closestA = ai;\n          closestB = bi;\n          closestC = ci;\n          closestFaceNormal.copy(faceNormal);\n        }\n      }\n\n      if (!localDistance) hits.splice(i, 1); // Update hit values from bounds-test\n\n      mesh.hit.localPoint.copy(direction).multiply(localDistance).add(origin);\n      mesh.hit.point.copy(mesh.hit.localPoint).applyMatrix4(mesh.worldMatrix);\n      mesh.hit.distance = mesh.hit.point.distance(this.origin); // Add unique hit objects on mesh to avoid generating lots of objects\n\n      if (!mesh.hit.faceNormal) {\n        mesh.hit.localFaceNormal = new Vec3();\n        mesh.hit.faceNormal = new Vec3();\n        mesh.hit.uv = new Vec2();\n        mesh.hit.localNormal = new Vec3();\n        mesh.hit.normal = new Vec3();\n      } // Add face normal data which is already computed\n\n\n      mesh.hit.localFaceNormal.copy(closestFaceNormal);\n      mesh.hit.faceNormal.copy(mesh.hit.localFaceNormal).transformDirection(mesh.worldMatrix); // Optional data, opt out to optimise a bit if necessary\n\n      if (includeUV || includeNormal) {\n        // Calculate barycoords to find uv values at hit point\n        a.fromArray(attributes.position.data, closestA * 3);\n        b.fromArray(attributes.position.data, closestB * 3);\n        c.fromArray(attributes.position.data, closestC * 3);\n        this.getBarycoord(mesh.hit.localPoint, a, b, c, barycoord);\n      }\n\n      if (includeUV && attributes.uv) {\n        uvA.fromArray(attributes.uv.data, closestA * 2);\n        uvB.fromArray(attributes.uv.data, closestB * 2);\n        uvC.fromArray(attributes.uv.data, closestC * 2);\n        mesh.hit.uv.set(uvA.x * barycoord.x + uvB.x * barycoord.y + uvC.x * barycoord.z, uvA.y * barycoord.x + uvB.y * barycoord.y + uvC.y * barycoord.z);\n      }\n\n      if (includeNormal && attributes.normal) {\n        a.fromArray(attributes.normal.data, closestA * 3);\n        b.fromArray(attributes.normal.data, closestB * 3);\n        c.fromArray(attributes.normal.data, closestC * 3);\n        mesh.hit.localNormal.set(a.x * barycoord.x + b.x * barycoord.y + c.x * barycoord.z, a.y * barycoord.x + b.y * barycoord.y + c.y * barycoord.z, a.z * barycoord.x + b.z * barycoord.y + c.z * barycoord.z);\n        mesh.hit.normal.copy(mesh.hit.localNormal).transformDirection(mesh.worldMatrix);\n      }\n    }\n\n    hits.sort((a, b) => a.hit.distance - b.hit.distance);\n    return hits;\n  }\n\n  intersectSphere(sphere, origin = this.origin, direction = this.direction) {\n    const ray = tempVec3c;\n    ray.sub(sphere.center, origin);\n    const tca = ray.dot(direction);\n    const d2 = ray.dot(ray) - tca * tca;\n    const radius2 = sphere.radius * sphere.radius;\n    if (d2 > radius2) return 0;\n    const thc = Math.sqrt(radius2 - d2);\n    const t0 = tca - thc;\n    const t1 = tca + thc;\n    if (t0 < 0 && t1 < 0) return 0;\n    if (t0 < 0) return t1;\n    return t0;\n  } // Ray AABB - Ray Axis aligned bounding box testing\n\n\n  intersectBox(box, origin = this.origin, direction = this.direction) {\n    let tmin, tmax, tYmin, tYmax, tZmin, tZmax;\n    const invdirx = 1 / direction.x;\n    const invdiry = 1 / direction.y;\n    const invdirz = 1 / direction.z;\n    const min = box.min;\n    const max = box.max;\n    tmin = ((invdirx >= 0 ? min.x : max.x) - origin.x) * invdirx;\n    tmax = ((invdirx >= 0 ? max.x : min.x) - origin.x) * invdirx;\n    tYmin = ((invdiry >= 0 ? min.y : max.y) - origin.y) * invdiry;\n    tYmax = ((invdiry >= 0 ? max.y : min.y) - origin.y) * invdiry;\n    if (tmin > tYmax || tYmin > tmax) return 0;\n    if (tYmin > tmin) tmin = tYmin;\n    if (tYmax < tmax) tmax = tYmax;\n    tZmin = ((invdirz >= 0 ? min.z : max.z) - origin.z) * invdirz;\n    tZmax = ((invdirz >= 0 ? max.z : min.z) - origin.z) * invdirz;\n    if (tmin > tZmax || tZmin > tmax) return 0;\n    if (tZmin > tmin) tmin = tZmin;\n    if (tZmax < tmax) tmax = tZmax;\n    if (tmax < 0) return 0;\n    return tmin >= 0 ? tmin : tmax;\n  }\n\n  intersectTriangle(a, b, c, backfaceCulling = true, origin = this.origin, direction = this.direction, normal = tempVec3g) {\n    // from https://github.com/mrdoob/three.js/blob/master/src/math/Ray.js\n    // which is from http://www.geometrictools.com/GTEngine/Include/Mathematics/GteIntrRay3Triangle3.h\n    const edge1 = tempVec3h;\n    const edge2 = tempVec3i;\n    const diff = tempVec3j;\n    edge1.sub(b, a);\n    edge2.sub(c, a);\n    normal.cross(edge1, edge2);\n    let DdN = direction.dot(normal);\n    if (!DdN) return 0;\n    let sign;\n\n    if (DdN > 0) {\n      if (backfaceCulling) return 0;\n      sign = 1;\n    } else {\n      sign = -1;\n      DdN = -DdN;\n    }\n\n    diff.sub(origin, a);\n    let DdQxE2 = sign * direction.dot(edge2.cross(diff, edge2));\n    if (DdQxE2 < 0) return 0;\n    let DdE1xQ = sign * direction.dot(edge1.cross(diff));\n    if (DdE1xQ < 0) return 0;\n    if (DdQxE2 + DdE1xQ > DdN) return 0;\n    let QdN = -sign * diff.dot(normal);\n    if (QdN < 0) return 0;\n    return QdN / DdN;\n  }\n\n  getBarycoord(point, a, b, c, target = tempVec3h) {\n    // From https://github.com/mrdoob/three.js/blob/master/src/math/Triangle.js\n    // static/instance method to calculate barycentric coordinates\n    // based on: http://www.blackpawn.com/texts/pointinpoly/default.html\n    const v0 = tempVec3i;\n    const v1 = tempVec3j;\n    const v2 = tempVec3k;\n    v0.sub(c, a);\n    v1.sub(b, a);\n    v2.sub(point, a);\n    const dot00 = v0.dot(v0);\n    const dot01 = v0.dot(v1);\n    const dot02 = v0.dot(v2);\n    const dot11 = v1.dot(v1);\n    const dot12 = v1.dot(v2);\n    const denom = dot00 * dot11 - dot01 * dot01;\n    if (denom === 0) return target.set(-2, -1, -1);\n    const invDenom = 1 / denom;\n    const u = (dot11 * dot02 - dot01 * dot12) * invDenom;\n    const v = (dot00 * dot12 - dot01 * dot02) * invDenom;\n    return target.set(1 - u - v, v, u);\n  }\n\n}\n\nconst CATMULLROM = 'catmullrom';\nconst CUBICBEZIER = 'cubicbezier';\nconst QUADRATICBEZIER = 'quadraticbezier'; // temp\n\nconst _a0 = new Vec3(),\n      _a1 = new Vec3(),\n      _a2 = new Vec3(),\n      _a3 = new Vec3();\n/**\n * Get the control points of cubic bezier curve.\n * @param {*} i\n * @param {*} a\n * @param {*} b\n */\n\n\nfunction getCtrlPoint(points, i, a = 0.168, b = 0.168) {\n  if (i < 1) {\n    _a0.sub(points[1], points[0]).scale(a).add(points[0]);\n  } else {\n    _a0.sub(points[i + 1], points[i - 1]).scale(a).add(points[i]);\n  }\n\n  if (i > points.length - 3) {\n    const last = points.length - 1;\n\n    _a1.sub(points[last - 1], points[last]).scale(b).add(points[last]);\n  } else {\n    _a1.sub(points[i], points[i + 2]).scale(b).add(points[i + 1]);\n  }\n\n  return [_a0.clone(), _a1.clone()];\n}\n\nfunction getQuadraticBezierPoint(t, p0, c0, p1) {\n  const k = 1 - t;\n\n  _a0.copy(p0).scale(k ** 2);\n\n  _a1.copy(c0).scale(2 * k * t);\n\n  _a2.copy(p1).scale(t ** 2);\n\n  const ret = new Vec3();\n  ret.add(_a0, _a1).add(_a2);\n  return ret;\n}\n\nfunction getCubicBezierPoint(t, p0, c0, c1, p1) {\n  const k = 1 - t;\n\n  _a0.copy(p0).scale(k ** 3);\n\n  _a1.copy(c0).scale(3 * k ** 2 * t);\n\n  _a2.copy(c1).scale(3 * k * t ** 2);\n\n  _a3.copy(p1).scale(t ** 3);\n\n  const ret = new Vec3();\n  ret.add(_a0, _a1).add(_a2).add(_a3);\n  return ret;\n}\n\nclass Curve {\n  constructor({\n    points = [new Vec3(0, 0, 0), new Vec3(0, 1, 0), new Vec3(1, 1, 0), new Vec3(1, 0, 0)],\n    divisions = 12,\n    type = Curve.CATMULLROM\n  } = {}) {\n    this.type = void 0;\n    this.points = void 0;\n    this.divisions = void 0;\n    this.points = points;\n    this.divisions = divisions;\n    this.type = type;\n  }\n\n  _getQuadraticBezierPoints(divisions = this.divisions) {\n    const points = [];\n    const count = this.points.length;\n\n    if (count < 3) {\n      console.warn('Not enough points provided.');\n      return [];\n    }\n\n    const p0 = this.points[0];\n    let c0 = this.points[1],\n        p1 = this.points[2];\n\n    for (let i = 0; i <= divisions; i++) {\n      const p = getQuadraticBezierPoint(i / divisions, p0, c0, p1);\n      points.push(p);\n    }\n\n    let offset = 3;\n\n    while (count - offset > 0) {\n      p0.copy(p1);\n      c0 = p1.scale(2).sub(c0);\n      p1 = this.points[offset];\n\n      for (let i = 1; i <= divisions; i++) {\n        const p = getQuadraticBezierPoint(i / divisions, p0, c0, p1);\n        points.push(p);\n      }\n\n      offset++;\n    }\n\n    return points;\n  }\n\n  _getCubicBezierPoints(divisions = this.divisions) {\n    const points = [];\n    const count = this.points.length;\n\n    if (count < 4) {\n      console.warn('Not enough points provided.');\n      return [];\n    }\n\n    let p0 = this.points[0],\n        c0 = this.points[1],\n        c1 = this.points[2],\n        p1 = this.points[3];\n\n    for (let i = 0; i <= divisions; i++) {\n      const p = getCubicBezierPoint(i / divisions, p0, c0, c1, p1);\n      points.push(p);\n    }\n\n    let offset = 4;\n\n    while (count - offset > 1) {\n      p0.copy(p1);\n      c0 = p1.scale(2).sub(c1);\n      c1 = this.points[offset];\n      p1 = this.points[offset + 1];\n\n      for (let i = 1; i <= divisions; i++) {\n        const p = getCubicBezierPoint(i / divisions, p0, c0, c1, p1);\n        points.push(p);\n      }\n\n      offset += 2;\n    }\n\n    return points;\n  }\n\n  _getCatmullRomPoints(divisions = this.divisions, a = 0.168, b = 0.168) {\n    const points = [];\n    const count = this.points.length;\n\n    if (count <= 2) {\n      return this.points;\n    }\n\n    let p0;\n    this.points.forEach((p, i) => {\n      if (i === 0) {\n        p0 = p;\n      } else {\n        const [c0, c1] = getCtrlPoint(this.points, i - 1, a, b);\n        const c = new Curve({\n          points: [p0, c0, c1, p],\n          type: Curve.CUBICBEZIER\n        });\n        points.pop();\n        points.push(...c.getPoints(divisions));\n        p0 = p;\n      }\n    });\n    return points;\n  }\n\n  getPoints(divisions = this.divisions, a = 0.168, b = 0.168) {\n    const type = this.type;\n\n    if (type === QUADRATICBEZIER) {\n      return this._getQuadraticBezierPoints(divisions);\n    }\n\n    if (type === CUBICBEZIER) {\n      return this._getCubicBezierPoints(divisions);\n    }\n\n    if (type === Curve.CATMULLROM) {\n      return this._getCatmullRomPoints(divisions, a, b);\n    }\n\n    return this.points;\n  }\n\n}\nCurve.CATMULLROM = 'catmullrom';\nCurve.CUBICBEZIER = 'cubicbezier';\nCurve.QUADRATICBEZIER = 'quadraticbezier';\nCurve.CATMULLROM = CATMULLROM;\nCurve.CUBICBEZIER = CUBICBEZIER;\nCurve.QUADRATICBEZIER = QUADRATICBEZIER;\n\n// TODO: Destroy render targets if size changed and exists\nclass Post {\n  constructor(gl, {\n    width,\n    height,\n    dpr,\n    wrapS = gl.CLAMP_TO_EDGE,\n    wrapT = gl.CLAMP_TO_EDGE,\n    minFilter = gl.LINEAR,\n    magFilter = gl.LINEAR,\n    geometry = new Triangle(gl),\n    targetOnly = null\n  } = {}) {\n    this.gl = void 0;\n    this.options = void 0;\n    this.passes = void 0;\n    this.geometry = void 0;\n    this.uniform = void 0;\n    this.targetOnly = void 0;\n    this.fbo = void 0;\n    this.dpr = void 0;\n    this.width = void 0;\n    this.height = void 0;\n    this.gl = gl;\n    this.options = {\n      wrapS,\n      wrapT,\n      minFilter,\n      magFilter\n    };\n    this.passes = [];\n    this.geometry = geometry;\n    this.uniform = {\n      value: null\n    };\n    this.targetOnly = targetOnly;\n    const fbo = this.fbo = {\n      read: null,\n      write: null,\n      swap: () => {\n        let temp = fbo.read;\n        fbo.read = fbo.write;\n        fbo.write = temp;\n      }\n    };\n    this.resize({\n      width,\n      height,\n      dpr\n    });\n  }\n\n  addPass({\n    vertex = defaultVertex,\n    fragment = defaultFragment,\n    uniforms = {},\n    textureUniform = 'tMap',\n    enabled = true\n  } = {}) {\n    uniforms[textureUniform] = {\n      value: this.fbo.read.texture\n    };\n    const program = new Program(this.gl, {\n      vertex,\n      fragment,\n      uniforms\n    });\n    const mesh = new Mesh(this.gl, {\n      geometry: this.geometry,\n      program\n    });\n    const pass = {\n      mesh,\n      program,\n      uniforms,\n      enabled,\n      textureUniform\n    };\n    this.passes.push(pass);\n    return pass;\n  }\n\n  resize({\n    width,\n    height,\n    dpr\n  } = {}) {\n    if (dpr) this.dpr = dpr;\n\n    if (width) {\n      this.width = width;\n      this.height = height || width;\n    }\n\n    dpr = this.dpr || this.gl.renderer.dpr;\n    width = (this.width || this.gl.renderer.width) * dpr;\n    height = (this.height || this.gl.renderer.height) * dpr;\n    this.options.width = width;\n    this.options.height = height;\n    this.fbo.read = new RenderTarget(this.gl, this.options);\n    this.fbo.write = new RenderTarget(this.gl, this.options);\n  } // Uses same arguments as renderer.render\n\n\n  render({\n    scene,\n    camera,\n    target = null,\n    update = true,\n    sort = true,\n    frustumCull = true\n  }) {\n    const enabledPasses = this.passes.filter(pass => pass.enabled);\n    this.gl.renderer.render({\n      scene,\n      camera,\n      target: enabledPasses.length || !target && this.targetOnly ? this.fbo.write : target,\n      update,\n      sort,\n      frustumCull\n    });\n    this.fbo.swap();\n    enabledPasses.forEach((pass, i) => {\n      pass.mesh.program.uniforms[pass.textureUniform].value = this.fbo.read.texture;\n      this.gl.renderer.render({\n        scene: pass.mesh,\n        target: i === enabledPasses.length - 1 && (target || !this.targetOnly) ? target : this.fbo.write,\n        clear: true\n      });\n      this.fbo.swap();\n    });\n    this.uniform.value = this.fbo.read.texture;\n  }\n\n}\nconst defaultVertex =\n/* glsl */\n`\n    attribute vec2 uv;\n    attribute vec2 position;\n\n    varying vec2 vUv;\n\n    void main() {\n        vUv = uv;\n        gl_Position = vec4(position, 0, 1);\n    }\n`;\nconst defaultFragment =\n/* glsl */\n`\n    precision highp float;\n\n    uniform sampler2D tMap;\n    varying vec2 vUv;\n\n    void main() {\n        gl_FragColor = texture2D(tMap, vUv);\n    }\n`;\n\nconst prevPos = new Vec3();\nconst prevRot = new Quat();\nconst prevScl = new Vec3();\nconst nextPos = new Vec3();\nconst nextRot = new Quat();\nconst nextScl = new Vec3();\nclass Animation {\n  constructor({\n    objects,\n    data\n  }) {\n    this.objects = void 0;\n    this.data = void 0;\n    this.elapsed = void 0;\n    this.weight = void 0;\n    this.duration = void 0;\n    this.objects = objects;\n    this.data = data;\n    this.elapsed = 0;\n    this.weight = 1;\n    this.duration = data.frames.length - 1;\n  }\n\n  update(totalWeight = 1, isSet) {\n    const weight = isSet ? 1 : this.weight / totalWeight;\n    const elapsed = this.elapsed % this.duration;\n    const floorFrame = Math.floor(elapsed);\n    const blend = elapsed - floorFrame;\n    const prevKey = this.data.frames[floorFrame];\n    const nextKey = this.data.frames[(floorFrame + 1) % this.duration];\n    this.objects.forEach((object, i) => {\n      prevPos.fromArray(prevKey.position, i * 3);\n      prevRot.fromArray(prevKey.quaternion, i * 4);\n      prevScl.fromArray(prevKey.scale, i * 3);\n      nextPos.fromArray(nextKey.position, i * 3);\n      nextRot.fromArray(nextKey.quaternion, i * 4);\n      nextScl.fromArray(nextKey.scale, i * 3);\n      prevPos.lerp(nextPos, blend);\n      prevRot.slerp(nextRot, blend);\n      prevScl.lerp(nextScl, blend);\n      object.position.lerp(prevPos, weight);\n      object.quaternion.slerp(prevRot, weight);\n      object.scale.lerp(prevScl, weight);\n    });\n  }\n\n}\n\nconst tempMat4$2 = new Mat4();\nclass Skin extends Mesh {\n  constructor(gl, {\n    rig,\n    geometry,\n    program,\n    mode = gl.TRIANGLES\n  } = {}) {\n    super(gl, {\n      geometry,\n      program,\n      mode\n    });\n    this.animations = void 0;\n    this.boneTexture = void 0;\n    this.boneTextureSize = void 0;\n    this.boneMatrices = void 0;\n    this.root = void 0;\n    this.bones = void 0;\n    this.createBones(rig);\n    this.createBoneTexture();\n    this.animations = [];\n    Object.assign(this.program.uniforms, {\n      boneTexture: {\n        value: this.boneTexture\n      },\n      boneTextureSize: {\n        value: this.boneTextureSize\n      }\n    });\n  }\n\n  createBones(rig) {\n    // Create root so that can simply update world matrix of whole skeleton\n    this.root = new Transform(); // Create bones\n\n    this.bones = [];\n    if (!rig.bones || !rig.bones.length) return;\n\n    for (let i = 0; i < rig.bones.length; i++) {\n      const bone = new Transform(); // Set initial values (bind pose)\n\n      bone.position.fromArray(rig.bindPose.position, i * 3);\n      bone.quaternion.fromArray(rig.bindPose.quaternion, i * 4);\n      bone.scale.fromArray(rig.bindPose.scale, i * 3);\n      this.bones.push(bone);\n    } // Once created, set the hierarchy\n\n\n    rig.bones.forEach((data, i) => {\n      this.bones[i].name = data.name;\n      if (data.parent === -1) return this.bones[i].setParent(this.root);\n      this.bones[i].setParent(this.bones[data.parent]);\n    }); // Then update to calculate world matrices\n\n    this.root.updateMatrixWorld(true); // Store inverse of bind pose to calculate differences\n\n    this.bones.forEach(bone => {\n      bone.bindInverse = new Mat4(...bone.worldMatrix).inverse();\n    });\n  }\n\n  createBoneTexture() {\n    if (!this.bones.length) return;\n    const size = Math.max(4, Math.pow(2, Math.ceil(Math.log(Math.sqrt(this.bones.length * 4)) / Math.LN2)));\n    this.boneMatrices = new Float32Array(size * size * 4);\n    this.boneTextureSize = size;\n    this.boneTexture = new Texture(this.gl, {\n      image: this.boneMatrices,\n      generateMipmaps: false,\n      type: this.gl.FLOAT,\n      internalFormat: isWebGl2(this.gl) ? this.gl.RGBA32F : this.gl.RGBA,\n      // internalFormat: this.gl.renderer.isWebgl2 ? this.gl.RGBA32F : this.gl.RGBA,\n      flipY: false,\n      width: size\n    });\n  }\n\n  addAnimation(data) {\n    const animation = new Animation({\n      objects: this.bones,\n      data\n    });\n    this.animations.push(animation);\n    return animation;\n  }\n\n  update() {\n    // Calculate combined animation weight\n    let total = 0;\n    this.animations.forEach(animation => total += animation.weight);\n    this.animations.forEach((animation, i) => {\n      // force first animation to set in order to reset frame\n      animation.update(total, i === 0);\n    });\n  }\n\n  draw({\n    camera\n  } = {}) {\n    // Update world matrices manually, as not part of scene graph\n    this.root.updateMatrixWorld(true); // Update bone texture\n\n    this.bones.forEach((bone, i) => {\n      // Find difference between current and bind pose\n      tempMat4$2.multiply(bone.worldMatrix, bone.bindInverse);\n      this.boneMatrices.set(tempMat4$2, i * 16);\n    });\n    if (this.boneTexture) this.boneTexture.needsUpdate = true;\n    super.draw({\n      camera\n    });\n  }\n\n}\n\nfunction Text({\n  font,\n  text,\n  width = Infinity,\n  align = 'left',\n  size = 1,\n  letterSpacing = 0,\n  lineHeight = 1.4,\n  wordSpacing = 0,\n  wordBreak = false\n}) {\n  const _this = this;\n\n  let glyphs, buffers;\n  let fontHeight, baseline, scale;\n  const newline = /\\n/;\n  const whitespace = /\\s/;\n  {\n    parseFont();\n    createGeometry();\n  }\n\n  function parseFont() {\n    glyphs = {};\n    font.chars.forEach(d => glyphs[d.char] = d);\n  }\n\n  function createGeometry() {\n    fontHeight = font.common.lineHeight;\n    baseline = font.common.base; // Use baseline so that actual text height is as close to 'size' value as possible\n\n    scale = size / baseline; // Strip spaces and newlines to get actual character length for buffers\n\n    let chars = text.replace(/[ \\n]/g, '');\n    let numChars = chars.length; // Create output buffers\n\n    buffers = {\n      position: new Float32Array(numChars * 4 * 3),\n      uv: new Float32Array(numChars * 4 * 2),\n      id: new Float32Array(numChars * 4),\n      index: new Uint16Array(numChars * 6)\n    }; // Set values for buffers that don't require calculation\n\n    for (let i = 0; i < numChars; i++) {\n      buffers.id[i] = i;\n      buffers.index.set([i * 4, i * 4 + 2, i * 4 + 1, i * 4 + 1, i * 4 + 2, i * 4 + 3], i * 6);\n    }\n\n    layout();\n  }\n\n  function layout() {\n    const lines = [];\n    let cursor = 0;\n    let wordCursor = 0;\n    let wordWidth = 0;\n    let line = newLine();\n\n    function newLine() {\n      const line = {\n        width: 0,\n        glyphs: []\n      };\n      lines.push(line);\n      wordCursor = cursor;\n      wordWidth = 0;\n      return line;\n    }\n\n    let maxTimes = 100;\n    let count = 0;\n\n    while (cursor < text.length && count < maxTimes) {\n      count++;\n      const char = text[cursor]; // Skip whitespace at start of line\n\n      if (!line.width && whitespace.test(char)) {\n        cursor++;\n        wordCursor = cursor;\n        wordWidth = 0;\n        continue;\n      } // If newline char, skip to next line\n\n\n      if (newline.test(char)) {\n        cursor++;\n        line = newLine();\n        continue;\n      }\n\n      const glyph = glyphs[char] || glyphs[' ']; // Find any applicable kern pairs\n\n      if (line.glyphs.length) {\n        const prevGlyph = line.glyphs[line.glyphs.length - 1][0];\n        let kern = getKernPairOffset(glyph.id, prevGlyph.id) * scale;\n        line.width += kern;\n        wordWidth += kern;\n      } // add char to line\n\n\n      line.glyphs.push([glyph, line.width]); // calculate advance for next glyph\n\n      let advance = 0; // If whitespace, update location of current word for line breaks\n\n      if (whitespace.test(char)) {\n        wordCursor = cursor;\n        wordWidth = 0; // Add wordspacing\n\n        advance += wordSpacing * size;\n      } else {\n        // Add letterspacing\n        advance += letterSpacing * size;\n      }\n\n      advance += glyph.xadvance * scale;\n      line.width += advance;\n      wordWidth += advance; // If width defined\n\n      if (line.width > width) {\n        // If can break words, undo latest glyph if line not empty and create new line\n        if (wordBreak && line.glyphs.length > 1) {\n          line.width -= advance;\n          line.glyphs.pop();\n          line = newLine();\n          continue; // If not first word, undo current word and cursor and create new line\n        } else if (!wordBreak && wordWidth !== line.width) {\n          let numGlyphs = cursor - wordCursor + 1;\n          line.glyphs.splice(-numGlyphs, numGlyphs);\n          cursor = wordCursor;\n          line.width -= wordWidth;\n          line = newLine();\n          continue;\n        }\n      }\n\n      cursor++;\n    } // Remove last line if empty\n\n\n    if (!line.width) lines.pop();\n    populateBuffers(lines);\n  }\n\n  function populateBuffers(lines) {\n    const texW = font.common.scaleW;\n    const texH = font.common.scaleH; // For all fonts tested, a little offset was needed to be right on the baseline, hence 0.07.\n\n    let y = 0.07 * size;\n    let j = 0;\n\n    for (let lineIndex = 0; lineIndex < lines.length; lineIndex++) {\n      let line = lines[lineIndex];\n\n      for (let i = 0; i < line.glyphs.length; i++) {\n        const glyph = line.glyphs[i][0];\n        let x = line.glyphs[i][1];\n\n        if (align === 'center') {\n          x -= line.width * 0.5;\n        } else if (align === 'right') {\n          x -= line.width;\n        } // If space, don't add to geometry\n\n\n        if (whitespace.test(glyph.char)) continue; // Apply char sprite offsets\n\n        x += glyph.xoffset * scale;\n        y -= glyph.yoffset * scale; // each letter is a quad. axis bottom left\n\n        let w = glyph.width * scale;\n        let h = glyph.height * scale;\n        buffers.position.set([x, y - h, 0, x, y, 0, x + w, y - h, 0, x + w, y, 0], j * 4 * 3);\n        let u = glyph.x / texW;\n        let uw = glyph.width / texW;\n        let v = 1.0 - glyph.y / texH;\n        let vh = glyph.height / texH;\n        buffers.uv.set([u, v - vh, u, v, u + uw, v - vh, u + uw, v], j * 4 * 2); // Reset cursor to baseline\n\n        y += glyph.yoffset * scale;\n        j++;\n      }\n\n      y -= size * lineHeight;\n    }\n\n    _this.buffers = buffers;\n    _this.numLines = lines.length;\n    _this.height = _this.numLines * size * lineHeight;\n  }\n\n  function getKernPairOffset(id1, id2) {\n    for (let i = 0; i < font.kernings.length; i++) {\n      let k = font.kernings[i];\n      if (k.first < id1) continue;\n      if (k.second < id2) continue;\n      if (k.first > id1) return 0;\n      if (k.first === id1 && k.second > id2) return 0;\n      return k.amount;\n    }\n\n    return 0;\n  } // Update buffers to layout with new layout\n\n\n  this.resize = function (options) {\n    ({\n      width\n    } = options);\n    layout();\n  }; // Completely change text (like creating new Text)\n\n\n  this.update = function (options) {\n    ({\n      text\n    } = options);\n    createGeometry();\n  };\n}\n\nconst vertex =\n/* glsl */\n`\n    precision highp float;\n    precision highp int;\n\n    attribute vec3 position;\n    attribute vec3 normal;\n\n    uniform mat3 normalMatrix;\n    uniform mat4 modelViewMatrix;\n    uniform mat4 projectionMatrix;\n\n    varying vec3 vNormal;\n\n    void main() {\n        vNormal = normalize(normalMatrix * normal);\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n    }\n`;\nconst fragment =\n/* glsl */\n`\n    precision highp float;\n    precision highp int;\n\n    varying vec3 vNormal;\n\n    void main() {\n        gl_FragColor.rgb = normalize(vNormal);\n        gl_FragColor.a = 1.0;\n    }\n`;\nfunction NormalProgram(gl) {\n  return new Program(gl, {\n    vertex: vertex,\n    fragment: fragment,\n    cullFace: null\n  });\n} // export class NormalProgram extends Program {\n//     public gltfMaterial;\n//     constructor(gl: OGLRenderingContext, options: Partial<ProgramOptions> = {}) {\n//         super(gl, options);\n//     }\n// }\n\nclass Flowmap {\n  constructor(gl, {\n    size = 128,\n    // default size of the render targets\n    falloff = 0.3,\n    // size of the stamp, percentage of the size\n    alpha = 1,\n    // opacity of the stamp\n    dissipation = 0.98,\n    // affects the speed that the stamp fades. Closer to 1 is slower\n    type // Pass in gl.FLOAT to force it, defaults to gl.HALF_FLOAT\n\n  } = {}) {\n    this.gl = void 0;\n    this.uniform = void 0;\n    this.mask = void 0;\n    this.aspect = void 0;\n    this.mouse = void 0;\n    this.velocity = void 0;\n    this.mesh = void 0;\n\n    const _this = this;\n\n    this.gl = gl; // output uniform containing render target textures\n\n    this.uniform = {\n      value: null\n    };\n    this.mask = {\n      read: null,\n      write: null,\n      // Helper function to ping pong the render targets and update the uniform\n      swap: () => {\n        let temp = _this.mask.read;\n        _this.mask.read = _this.mask.write;\n        _this.mask.write = temp;\n        _this.uniform.value = _this.mask.read.texture;\n      }\n    };\n    {\n      createFBOs();\n      this.aspect = 1;\n      this.mouse = new Vec2();\n      this.velocity = new Vec2();\n      this.mesh = initProgram();\n    }\n\n    function createFBOs() {\n      // Requested type not supported, fall back to half float\n      if (!type) type = gl.HALF_FLOAT || gl.renderer.extensions['OES_texture_half_float'].HALF_FLOAT_OES;\n\n      let minFilter = (() => {\n        if (gl.renderer.isWebgl2) return gl.LINEAR;\n        if (gl.renderer.extensions[`OES_texture_${type === gl.FLOAT ? '' : 'half_'}float_linear`]) return gl.LINEAR;\n        return gl.NEAREST;\n      })();\n\n      const options = {\n        width: size,\n        height: size,\n        type: type,\n        format: gl.RGBA,\n        internalFormat: gl.renderer.isWebgl2 ? type === gl.FLOAT ? gl.RGBA32F : gl.RGBA16F : gl.RGBA,\n        minFilter,\n        depth: false\n      };\n      _this.mask.read = new RenderTarget(gl, options);\n      _this.mask.write = new RenderTarget(gl, options);\n\n      _this.mask.swap();\n    }\n\n    function initProgram() {\n      return new Mesh(gl, {\n        // Triangle that includes -1 to 1 range for 'position', and 0 to 1 range for 'uv'.\n        geometry: new Triangle(gl),\n        program: new Program(gl, {\n          vertex: vertex$1,\n          fragment: fragment$1,\n          uniforms: {\n            tMap: _this.uniform,\n            uFalloff: {\n              value: falloff * 0.5\n            },\n            uAlpha: {\n              value: alpha\n            },\n            uDissipation: {\n              value: dissipation\n            },\n            // User needs to update these\n            uAspect: {\n              value: 1\n            },\n            uMouse: {\n              value: _this.mouse\n            },\n            uVelocity: {\n              value: _this.velocity\n            }\n          },\n          depthTest: false\n        })\n      });\n    }\n  }\n\n  update() {\n    this.mesh.program.uniforms.uAspect.value = this.aspect;\n    this.gl.renderer.render({\n      scene: this.mesh,\n      target: this.mask.write,\n      clear: false\n    });\n    this.mask.swap();\n  }\n\n}\nconst vertex$1 =\n/* glsl */\n`\n    attribute vec2 uv;\n    attribute vec2 position;\n\n    varying vec2 vUv;\n\n    void main() {\n        vUv = uv;\n        gl_Position = vec4(position, 0, 1);\n    }\n`;\nconst fragment$1 =\n/* glsl */\n`\n    precision highp float;\n\n    uniform sampler2D tMap;\n\n    uniform float uFalloff;\n    uniform float uAlpha;\n    uniform float uDissipation;\n    \n    uniform float uAspect;\n    uniform vec2 uMouse;\n    uniform vec2 uVelocity;\n\n    varying vec2 vUv;\n\n    void main() {\n        vec4 color = texture2D(tMap, vUv) * uDissipation;\n\n        vec2 cursor = vUv - uMouse;\n        cursor.x *= uAspect;\n\n        vec3 stamp = vec3(uVelocity * vec2(1, -1), 1.0 - pow(1.0 - min(1.0, length(uVelocity)), 3.0));\n        float falloff = smoothstep(uFalloff, 0.0, length(cursor)) * uAlpha;\n\n        color.rgb = mix(color.rgb, stamp, vec3(falloff));\n\n        gl_FragColor = color;\n    }\n`;\n\nclass GPGPU {\n  constructor(gl, {\n    // Always pass in array of vec4s (RGBA values within texture)\n    data = new Float32Array(16),\n    geometry = new Triangle(gl),\n    type = null // Pass in gl.FLOAT to force it, defaults to gl.HALF_FLOAT\n\n  }) {\n    this.gl = void 0;\n    this.passes = void 0;\n    this.geometry = void 0;\n    this.dataLength = void 0;\n    this.size = void 0;\n    this.coords = void 0;\n    this.uniform = void 0;\n    this.fbo = void 0;\n    this.gl = gl;\n    const initialData = data;\n    this.passes = [];\n    this.geometry = geometry;\n    this.dataLength = initialData.length / 4; // Windows and iOS only like power of 2 textures\n    // Find smallest PO2 that fits data\n\n    this.size = Math.pow(2, Math.ceil(Math.log(Math.ceil(Math.sqrt(this.dataLength))) / Math.LN2)); // Create coords for output texture\n\n    this.coords = new Float32Array(this.dataLength * 2);\n\n    for (let i = 0; i < this.dataLength; i++) {\n      const x = i % this.size / this.size; // to add 0.5 to be center pixel ?\n\n      const y = Math.floor(i / this.size) / this.size;\n      this.coords.set([x, y], i * 2);\n    } // Use original data if already correct length of PO2 texture, else copy to new array of correct length\n\n\n    const floatArray = (() => {\n      if (initialData.length === this.size * this.size * 4) {\n        return initialData;\n      } else {\n        const a = new Float32Array(this.size * this.size * 4);\n        a.set(initialData);\n        return a;\n      }\n    })(); // Create output texture uniform using input float texture with initial data\n\n\n    this.uniform = {\n      value: new Texture(gl, {\n        image: floatArray,\n        target: gl.TEXTURE_2D,\n        type: gl.FLOAT,\n        format: gl.RGBA,\n        internalFormat: gl.renderer.isWebgl2 ? gl.RGBA32F : gl.RGBA,\n        wrapS: gl.CLAMP_TO_EDGE,\n        wrapT: gl.CLAMP_TO_EDGE,\n        generateMipmaps: false,\n        minFilter: gl.NEAREST,\n        magFilter: gl.NEAREST,\n        width: this.size,\n        flipY: false\n      })\n    }; // Create FBOs\n\n    const options = {\n      width: this.size,\n      height: this.size,\n      type: type || gl.HALF_FLOAT || gl.renderer.extensions['OES_texture_half_float'].HALF_FLOAT_OES,\n      format: gl.RGBA,\n      internalFormat: gl.renderer.isWebgl2 ? type === gl.FLOAT ? gl.RGBA32F : gl.RGBA16F : gl.RGBA,\n      minFilter: gl.NEAREST,\n      depth: false,\n      unpackAlignment: 1\n    };\n    this.fbo = {\n      read: new RenderTarget(gl, options),\n      write: new RenderTarget(gl, options),\n      swap: () => {\n        let temp = this.fbo.read;\n        this.fbo.read = this.fbo.write;\n        this.fbo.write = temp;\n        this.uniform.value = this.fbo.read.texture;\n      }\n    };\n  }\n\n  addPass({\n    vertex = defaultVertex$1,\n    fragment = defaultFragment$1,\n    uniforms = {},\n    textureUniform = 'tMap',\n    enabled = true\n  } = {}) {\n    uniforms[textureUniform] = this.uniform;\n    const program = new Program(this.gl, {\n      vertex,\n      fragment,\n      uniforms\n    });\n    const mesh = new Mesh(this.gl, {\n      geometry: this.geometry,\n      program\n    });\n    const pass = {\n      mesh,\n      program,\n      uniforms,\n      enabled,\n      textureUniform\n    };\n    this.passes.push(pass);\n    return pass;\n  }\n\n  render() {\n    const enabledPasses = this.passes.filter(pass => pass.enabled);\n    enabledPasses.forEach((pass, i) => {\n      this.gl.renderer.render({\n        scene: pass.mesh,\n        target: this.fbo.write,\n        clear: false\n      });\n      this.fbo.swap();\n    });\n  }\n\n}\nconst defaultVertex$1 =\n/* glsl */\n`\n    attribute vec2 uv;\n    attribute vec2 position;\n\n    varying vec2 vUv;\n\n    void main() {\n        vUv = uv;\n        gl_Position = vec4(position, 0, 1);\n    }\n`;\nconst defaultFragment$1 =\n/* glsl */\n`\n    precision highp float;\n\n    uniform sampler2D tMap;\n    varying vec2 vUv;\n\n    void main() {\n        gl_FragColor = texture2D(tMap, vUv);\n    }\n`;\n\nconst tmp = new Vec3();\nclass Polyline {\n  // uniforms\n  constructor(gl, {\n    points,\n    // Array of Vec3s\n    vertex = defaultVertex$2,\n    fragment = defaultFragment$2,\n    uniforms = {},\n    attributes = {} // For passing in custom attribs\n\n  }) {\n    this.gl = void 0;\n    this.points = void 0;\n    this.count = void 0;\n    this.position = void 0;\n    this.prev = void 0;\n    this.next = void 0;\n    this.geometry = void 0;\n    this.resolution = void 0;\n    this.dpr = void 0;\n    this.thickness = void 0;\n    this.color = void 0;\n    this.miter = void 0;\n    this.program = void 0;\n    this.mesh = void 0;\n    this.gl = gl;\n    this.points = points;\n    this.count = points.length; // Create buffers\n\n    this.position = new Float32Array(this.count * 3 * 2);\n    this.prev = new Float32Array(this.count * 3 * 2);\n    this.next = new Float32Array(this.count * 3 * 2);\n    const side = new Float32Array(this.count * 1 * 2);\n    const uv = new Float32Array(this.count * 2 * 2);\n    const index = new Uint16Array((this.count - 1) * 3 * 2); // Set static buffers\n\n    for (let i = 0; i < this.count; i++) {\n      side.set([-1, 1], i * 2);\n      const v = i / (this.count - 1);\n      uv.set([0, v, 1, v], i * 4);\n      if (i === this.count - 1) continue;\n      const ind = i * 2;\n      index.set([ind + 0, ind + 1, ind + 2], (ind + 0) * 3);\n      index.set([ind + 2, ind + 1, ind + 3], (ind + 1) * 3);\n    }\n\n    const geometry = this.geometry = new Geometry(gl, Object.assign(attributes, {\n      position: {\n        size: 3,\n        data: this.position\n      },\n      prev: {\n        size: 3,\n        data: this.prev\n      },\n      next: {\n        size: 3,\n        data: this.next\n      },\n      side: {\n        size: 1,\n        data: side\n      },\n      uv: {\n        size: 2,\n        data: uv\n      },\n      index: {\n        size: 1,\n        data: index\n      }\n    })); // Populate dynamic buffers\n\n    this.updateGeometry();\n    if (!uniforms.uResolution) this.resolution = uniforms.uResolution = {\n      value: new Vec2()\n    };\n    if (!uniforms.uDPR) this.dpr = uniforms.uDPR = {\n      value: 1\n    };\n    if (!uniforms.uThickness) this.thickness = uniforms.uThickness = {\n      value: 1\n    };\n    if (!uniforms.uColor) this.color = uniforms.uColor = {\n      value: new Color('#000')\n    };\n    if (!uniforms.uMiter) this.miter = uniforms.uMiter = {\n      value: 1\n    }; // Set size uniforms' values\n\n    this.resize();\n    const program = this.program = new Program(gl, {\n      vertex,\n      fragment,\n      uniforms\n    });\n    this.mesh = new Mesh(gl, {\n      geometry,\n      program\n    });\n  }\n\n  updateGeometry() {\n    this.points.forEach((p, i) => {\n      p.toArray(this.position, i * 3 * 2);\n      p.toArray(this.position, i * 3 * 2 + 3);\n\n      if (!i) {\n        // If first point, calculate prev using the distance to 2nd point\n        tmp.copy(p).sub(this.points[i + 1]).add(p);\n        tmp.toArray(this.prev, i * 3 * 2);\n        tmp.toArray(this.prev, i * 3 * 2 + 3);\n      } else {\n        p.toArray(this.next, (i - 1) * 3 * 2);\n        p.toArray(this.next, (i - 1) * 3 * 2 + 3);\n      }\n\n      if (i === this.points.length - 1) {\n        // If last point, calculate next using distance to 2nd last point\n        tmp.copy(p).sub(this.points[i - 1]).add(p);\n        tmp.toArray(this.next, i * 3 * 2);\n        tmp.toArray(this.next, i * 3 * 2 + 3);\n      } else {\n        p.toArray(this.prev, (i + 1) * 3 * 2);\n        p.toArray(this.prev, (i + 1) * 3 * 2 + 3);\n      }\n    });\n    this.geometry.attributes.position.needsUpdate = true;\n    this.geometry.attributes.prev.needsUpdate = true;\n    this.geometry.attributes.next.needsUpdate = true;\n  } // Only need to call if not handling resolution uniforms manually\n\n\n  resize() {\n    // Update automatic uniforms if not overridden\n    if (this.resolution) this.resolution.value.set(this.gl.canvas.width, this.gl.canvas.height);\n    if (this.dpr) this.dpr.value = this.gl.renderer.dpr;\n  }\n\n}\nconst defaultVertex$2 =\n/* glsl */\n`\n    precision highp float;\n\n    attribute vec3 position;\n    attribute vec3 next;\n    attribute vec3 prev;\n    attribute vec2 uv;\n    attribute float side;\n\n    uniform mat4 modelViewMatrix;\n    uniform mat4 projectionMatrix;\n    uniform vec2 uResolution;\n    uniform float uDPR;\n    uniform float uThickness;\n    uniform float uMiter;\n\n    varying vec2 vUv;\n\n    vec4 getPosition() {\n        mat4 mvp = projectionMatrix * modelViewMatrix;\n        vec4 current = mvp * vec4(position, 1);\n        vec4 nextPos = mvp * vec4(next, 1);\n        vec4 prevPos = mvp * vec4(prev, 1);\n\n        vec2 aspect = vec2(uResolution.x / uResolution.y, 1);    \n        vec2 currentScreen = current.xy / current.w * aspect;\n        vec2 nextScreen = nextPos.xy / nextPos.w * aspect;\n        vec2 prevScreen = prevPos.xy / prevPos.w * aspect;\n    \n        vec2 dir1 = normalize(currentScreen - prevScreen);\n        vec2 dir2 = normalize(nextScreen - currentScreen);\n        vec2 dir = normalize(dir1 + dir2);\n    \n        vec2 normal = vec2(-dir.y, dir.x);\n        normal /= mix(1.0, max(0.3, dot(normal, vec2(-dir1.y, dir1.x))), uMiter);\n        normal /= aspect;\n\n        float pixelWidthRatio = 1.0 / (uResolution.y / uDPR);\n        float pixelWidth = current.w * pixelWidthRatio;\n        normal *= pixelWidth * uThickness;\n        current.xy -= normal * side;\n    \n        return current;\n    }\n\n    void main() {\n        vUv = uv;\n        gl_Position = getPosition();\n    }\n`;\nconst defaultFragment$2 =\n/* glsl */\n`\n    precision highp float;\n\n    uniform vec3 uColor;\n    \n    varying vec2 vUv;\n\n    void main() {\n        gl_FragColor.rgb = uColor;\n        gl_FragColor.a = 1.0;\n    }\n`;\n\nclass Shadow {\n  constructor(gl, {\n    light = new Camera(gl),\n    width = 1024,\n    height = width\n  }) {\n    this.gl = void 0;\n    this.light = void 0;\n    this.target = void 0;\n    this.depthProgram = void 0;\n    this.castMeshes = void 0;\n    this.gl = gl;\n    this.light = light;\n    this.target = new RenderTarget(gl, {\n      width,\n      height\n    });\n    this.depthProgram = new Program(gl, {\n      vertex: defaultVertex$3,\n      fragment: defaultFragment$3,\n      cullFace: null\n    });\n    this.castMeshes = [];\n  }\n\n  add({\n    mesh,\n    receive = true,\n    cast = true,\n    vertex = defaultVertex$3,\n    fragment = defaultFragment$3,\n    uniformProjection = 'shadowProjectionMatrix',\n    uniformView = 'shadowViewMatrix',\n    uniformTexture = 'tShadow'\n  }) {\n    // Add uniforms to existing program\n    if (receive && !mesh.program.uniforms[uniformProjection]) {\n      mesh.program.uniforms[uniformProjection] = {\n        value: this.light.projectionMatrix\n      };\n      mesh.program.uniforms[uniformView] = {\n        value: this.light.viewMatrix\n      };\n      mesh.program.uniforms[uniformTexture] = {\n        value: this.target.texture\n      };\n    }\n\n    if (!cast) return;\n    this.castMeshes.push(mesh); // Store program for when switching between depth override\n\n    mesh.colorProgram = mesh.program; // Check if depth program already attached\n\n    if (mesh.depthProgram) return; // Use global depth override if nothing custom passed in\n\n    if (vertex === defaultVertex$3 && fragment === defaultFragment$3) {\n      mesh.depthProgram = this.depthProgram;\n      return;\n    } // Create custom override program\n\n\n    mesh.depthProgram = new Program(this.gl, {\n      vertex,\n      fragment,\n      cullFace: null\n    });\n  }\n\n  render({\n    scene\n  }) {\n    // For depth render, replace program with depth override.\n    // Hide meshes not casting shadows.\n    scene.traverse(node => {\n      if (!node.draw) return;\n\n      if (!!~this.castMeshes.indexOf(node)) {\n        node.program = node.depthProgram;\n      } else {\n        node.isForceVisibility = node.visible;\n        node.visible = false;\n      }\n    }); // Render the depth shadow map using the light as the camera\n\n    this.gl.renderer.render({\n      scene,\n      camera: this.light,\n      target: this.target\n    }); // Then switch the program back to the normal one\n\n    scene.traverse(node => {\n      if (!node.draw) return;\n\n      if (!!~this.castMeshes.indexOf(node)) {\n        node.program = node.colorProgram;\n      } else {\n        node.visible = node.isForceVisibility;\n      }\n    });\n  }\n\n}\nconst defaultVertex$3 =\n/* glsl */\n`\n    attribute vec3 position;\n    attribute vec2 uv;\n\n    uniform mat4 modelViewMatrix;\n    uniform mat4 projectionMatrix;\n\n    void main() {\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n    }\n`;\nconst defaultFragment$3 =\n/* glsl */\n`\n    precision highp float;\n\n    vec4 packRGBA (float v) {\n        vec4 pack = fract(vec4(1.0, 255.0, 65025.0, 16581375.0) * v);\n        pack -= pack.yzww * vec2(1.0 / 255.0, 0.0).xxxy;\n        return pack;\n    }\n\n    void main() {\n        gl_FragColor = packRGBA(gl_FragCoord.z);\n    }\n`;\n\n// Generate textures using https://github.com/TimvanScherpenzeel/texture-compressor\n\nclass KTXTexture extends Texture {\n  constructor(gl, {\n    buffer,\n    wrapS = gl.CLAMP_TO_EDGE,\n    wrapT = gl.CLAMP_TO_EDGE,\n    anisotropy = 0,\n    minFilter,\n    magFilter\n  } = {}) {\n    super(gl, {\n      generateMipmaps: false,\n      wrapS,\n      wrapT,\n      anisotropy,\n      minFilter,\n      magFilter\n    });\n    if (buffer) this.parseBuffer(buffer);\n  }\n\n  parseBuffer(buffer) {\n    const ktx = new KhronosTextureContainer(buffer);\n    ktx.mipmaps.isCompressedTexture = true; // Update texture\n\n    this.image = ktx.mipmaps;\n    this.internalFormat = ktx.glInternalFormat;\n\n    if (ktx.numberOfMipmapLevels > 1) {\n      if (this.minFilter === this.gl.LINEAR) this.minFilter = this.gl.NEAREST_MIPMAP_LINEAR;\n    } else {\n      if (this.minFilter === this.gl.NEAREST_MIPMAP_LINEAR) this.minFilter = this.gl.LINEAR;\n    } // TODO: support cube maps\n    // ktx.numberOfFaces\n\n  }\n\n}\n\nclass KhronosTextureContainer {\n  constructor(buffer) {\n    this.glInternalFormat = void 0;\n    this.numberOfFaces = void 0;\n    this.numberOfMipmapLevels = void 0;\n    this.mipmaps = void 0;\n    this.isCompressedTexture = void 0;\n    const idCheck = [0xab, 0x4b, 0x54, 0x58, 0x20, 0x31, 0x31, 0xbb, 0x0d, 0x0a, 0x1a, 0x0a];\n    const id = new Uint8Array(buffer, 0, 12);\n\n    for (let i = 0; i < id.length; i++) if (id[i] !== idCheck[i]) {\n      console.error('File missing KTX identifier');\n      return;\n    } // TODO: Is this always 4? Tested: [android, macos]\n\n\n    const size = Uint32Array.BYTES_PER_ELEMENT;\n    const head = new DataView(buffer, 12, 13 * size);\n    const littleEndian = head.getUint32(0, true) === 0x04030201;\n    const glType = head.getUint32(1 * size, littleEndian);\n\n    if (glType !== 0) {\n      console.warn('only compressed formats currently supported');\n      return;\n    }\n\n    this.glInternalFormat = head.getUint32(4 * size, littleEndian);\n    let width = head.getUint32(6 * size, littleEndian);\n    let height = head.getUint32(7 * size, littleEndian);\n    this.numberOfFaces = head.getUint32(10 * size, littleEndian);\n    this.numberOfMipmapLevels = Math.max(1, head.getUint32(11 * size, littleEndian));\n    const bytesOfKeyValueData = head.getUint32(12 * size, littleEndian);\n    this.mipmaps = [];\n    let offset = 12 + 13 * 4 + bytesOfKeyValueData;\n\n    for (let level = 0; level < this.numberOfMipmapLevels; level++) {\n      const levelSize = new Int32Array(buffer, offset, 1)[0]; // size per face, since not supporting array cubemaps\n\n      offset += 4; // levelSize field\n\n      for (let face = 0; face < this.numberOfFaces; face++) {\n        const data = new Uint8Array(buffer, offset, levelSize);\n        this.mipmaps.push({\n          data,\n          width,\n          height\n        });\n        offset += levelSize;\n        offset += 3 - (levelSize + 3) % 4; // add padding for odd sized image\n      }\n\n      width = width >> 1;\n      height = height >> 1;\n    }\n  }\n\n}\n\n// For compressed textures, generate using https://github.com/TimvanScherpenzeel/texture-compressor\nlet cache = {};\nconst supportedExtensions = [];\nclass TextureLoader {\n  static load(gl, {\n    src,\n    // string or object of extension:src key-values\n    // {\n    //     pvrtc: '...ktx',\n    //     s3tc: '...ktx',\n    //     etc: '...ktx',\n    //     etc1: '...ktx',\n    //     astc: '...ktx',\n    //     webp: '...webp',\n    //     jpg: '...jpg',\n    //     png: '...png',\n    // }\n    // Only props relevant to KTXTexture\n    wrapS = gl.CLAMP_TO_EDGE,\n    wrapT = gl.CLAMP_TO_EDGE,\n    anisotropy = 0,\n    // For regular images\n    format = gl.RGBA,\n    internalFormat = format,\n    generateMipmaps = true,\n    minFilter = generateMipmaps ? gl.NEAREST_MIPMAP_LINEAR : gl.LINEAR,\n    magFilter = gl.LINEAR,\n    premultiplyAlpha = false,\n    unpackAlignment = 4,\n    flipY = true\n  } = {}) {\n    const support = TextureLoader.getSupportedExtensions(gl);\n    let ext = 'none'; // If src is string, determine which format from the extension\n\n    if (typeof src === 'string') {\n      ext = src.split('.').pop().split('?')[0].toLowerCase();\n    } // If src is object, use supported extensions and provided list to choose best option\n    // Get first supported match, so put in order of preference\n\n\n    if (typeof src === 'object') {\n      for (const prop in src) {\n        if (support.includes(prop.toLowerCase())) {\n          ext = prop.toLowerCase();\n          src = src[prop];\n          break;\n        }\n      }\n    } // Stringify props\n\n\n    const cacheID = String(src) + wrapS + wrapT + anisotropy + format + internalFormat + generateMipmaps + minFilter + magFilter + premultiplyAlpha + unpackAlignment + flipY + gl.renderer.id; // Check cache for existing texture\n\n    if (cache[cacheID]) return cache[cacheID];\n    let texture;\n\n    switch (ext) {\n      case 'ktx':\n      case 'pvrtc':\n      case 's3tc':\n      case 'etc':\n      case 'etc1':\n      case 'astc':\n        // Load compressed texture using KTX format\n        texture = new KTXTexture(gl, {\n          src: src,\n          wrapS,\n          wrapT,\n          anisotropy,\n          minFilter,\n          magFilter\n        });\n        texture.loaded = this.loadKTX(src, texture);\n        break;\n\n      case 'webp':\n      case 'jpg':\n      case 'jpeg':\n      case 'png':\n        texture = new Texture(gl, {\n          wrapS,\n          wrapT,\n          anisotropy,\n          format,\n          internalFormat,\n          generateMipmaps,\n          minFilter,\n          magFilter,\n          premultiplyAlpha,\n          unpackAlignment,\n          flipY\n        });\n        texture.loaded = this.loadImage(gl, src, texture);\n        break;\n\n      default:\n        console.warn('No supported format supplied');\n        texture = new Texture(gl);\n    }\n\n    texture.ext = ext;\n    cache[cacheID] = texture;\n    return texture;\n  }\n\n  static getSupportedExtensions(gl) {\n    if (supportedExtensions.length) return supportedExtensions;\n    const extensions = {\n      pvrtc: gl.renderer.getExtension('WEBGL_compressed_texture_pvrtc') || gl.renderer.getExtension('WEBKIT_WEBGL_compressed_texture_pvrtc'),\n      s3tc: gl.renderer.getExtension('WEBGL_compressed_texture_s3tc') || gl.renderer.getExtension('MOZ_WEBGL_compressed_texture_s3tc') || gl.renderer.getExtension('WEBKIT_WEBGL_compressed_texture_s3tc'),\n      etc: gl.renderer.getExtension('WEBGL_compressed_texture_etc'),\n      etc1: gl.renderer.getExtension('WEBGL_compressed_texture_etc1'),\n      astc: gl.renderer.getExtension('WEBGL_compressed_texture_astc')\n    };\n\n    for (const ext in extensions) if (extensions[ext]) supportedExtensions.push(ext); // Check for WebP support\n\n\n    if (detectWebP) supportedExtensions.push('webp'); // Formats supported by all\n\n    supportedExtensions.push('png', 'jpg');\n    return supportedExtensions;\n  }\n\n  static loadKTX(src, texture) {\n    return fetch(src).then(res => res.arrayBuffer()).then(buffer => texture.parseBuffer(buffer));\n  }\n\n  static loadImage(gl, src, texture) {\n    return decodeImage(src).then(imgBmp => {\n      // Catch non POT textures and update params to avoid errors\n      if (!powerOfTwo(imgBmp.width) || !powerOfTwo(imgBmp.height)) {\n        if (texture.generateMipmaps) texture.generateMipmaps = false;\n        if (texture.minFilter === gl.NEAREST_MIPMAP_LINEAR) texture.minFilter = gl.LINEAR;\n        if (texture.wrapS === gl.REPEAT) texture.wrapS = texture.wrapT = gl.CLAMP_TO_EDGE;\n      }\n\n      texture.image = imgBmp; // For createImageBitmap, close once uploaded\n\n      texture.onUpdate = () => {\n        if (imgBmp.close) imgBmp.close();\n        texture.onUpdate = null;\n      };\n\n      return imgBmp;\n    });\n  }\n\n  static clearCache() {\n    cache = {};\n  }\n\n}\n\nfunction detectWebP() {\n  return document.createElement('canvas').toDataURL('image/webp').indexOf('data:image/webp') == 0;\n}\n\nfunction powerOfTwo(value) {\n  return Math.log2(value) % 1 === 0;\n}\n\nfunction decodeImage(src) {\n  return new Promise(resolve => {\n    const img = new Image();\n    img.crossOrigin = '';\n    img.src = src; // Only chrome's implementation of createImageBitmap is fully supported\n    // const isChrome = navigator.userAgent.toLowerCase().includes('chrome');\n    // if (!!window.createImageBitmap && isChrome) {\n    //     img.onload = () => {\n    //         createImageBitmap(img, {\n    //             imageOrientation: 'flipY',\n    //             premultiplyAlpha: 'none',\n    //         }).then(imgBmp => {\n    //             resolve(imgBmp);\n    //         });\n    //     };\n    // } else {\n\n    img.onload = () => resolve(img); // }\n\n  });\n}\n\nconst tmpVec3A = new Vec3();\nconst tmpVec3B = new Vec3();\nconst tmpVec3C = new Vec3();\nconst tmpVec3D = new Vec3();\nconst tmpQuatA = new Quat();\nconst tmpQuatB = new Quat();\nconst tmpQuatC = new Quat();\nconst tmpQuatD = new Quat();\nclass GLTFAnimation {\n  constructor(data, weight = 1) {\n    this.data = void 0;\n    this.elapsed = void 0;\n    this.weight = void 0;\n    this.loop = void 0;\n    this.duration = void 0;\n    this.data = data;\n    this.elapsed = 0;\n    this.weight = weight; // Set to false to not apply modulo to elapsed against duration\n\n    this.loop = true; // Get duration from largest final time in all channels\n\n    this.duration = data.reduce((a, {\n      times\n    }) => Math.max(a, times[times.length - 1]), 0);\n  }\n\n  update(totalWeight = 1, isSet) {\n    const weight = isSet ? 1 : this.weight / totalWeight;\n    const elapsed = this.loop ? this.elapsed % this.duration : Math.min(this.elapsed, this.duration);\n    this.data.forEach(({\n      node,\n      transform,\n      interpolation,\n      times,\n      values\n    }) => {\n      // Get index of two time values elapsed is between\n      const prevIndex = Math.max(1, times.findIndex(t => t > elapsed)) - 1;\n      const nextIndex = prevIndex + 1; // Get linear blend/alpha between the two\n\n      let alpha = (elapsed - times[prevIndex]) / (times[nextIndex] - times[prevIndex]);\n      if (interpolation === 'STEP') alpha = 0;\n      let prevVal = tmpVec3A;\n      let prevTan = tmpVec3B;\n      let nextTan = tmpVec3C;\n      let nextVal = tmpVec3D;\n      let size = 3;\n\n      if (transform === 'quaternion') {\n        prevVal = tmpQuatA;\n        prevTan = tmpQuatB;\n        nextTan = tmpQuatC;\n        nextVal = tmpQuatD;\n        size = 4;\n      }\n\n      if (interpolation === 'CUBICSPLINE') {\n        // Get the prev and next values from the indices\n        prevVal.fromArray(values, prevIndex * size * 3 + size * 1);\n        prevTan.fromArray(values, prevIndex * size * 3 + size * 2);\n        nextTan.fromArray(values, nextIndex * size * 3 + size * 0);\n        nextVal.fromArray(values, nextIndex * size * 3 + size * 1); // interpolate for final value\n\n        prevVal = this.cubicSplineInterpolate(alpha, prevVal, prevTan, nextTan, nextVal);\n        if (size === 4) prevVal.normalize();\n      } else {\n        // Get the prev and next values from the indices\n        prevVal.fromArray(values, prevIndex * size);\n        nextVal.fromArray(values, nextIndex * size); // interpolate for final value\n\n        if (size === 4) prevVal.slerp(nextVal, alpha);else prevVal.lerp(nextVal, alpha);\n      } // interpolate between multiple possible animations\n\n\n      if (size === 4) node[transform].slerp(prevVal, weight);else node[transform].lerp(prevVal, weight);\n    });\n  }\n\n  cubicSplineInterpolate(t, prevVal, prevTan, nextTan, nextVal) {\n    const t2 = t * t;\n    const t3 = t2 * t;\n    const s2 = 3 * t2 - 2 * t3;\n    const s3 = t3 - t2;\n    const s0 = 1 - s2;\n    const s1 = s3 - t2 + t;\n\n    for (let i = 0; i < prevVal.length; i++) {\n      prevVal[i] = s0 * prevVal[i] + s1 * (1 - t) * prevTan[i] + s2 * nextVal[i] + s3 * t * nextTan[i];\n    }\n\n    return prevVal;\n  }\n\n}\n\nconst tempMat4$3 = new Mat4();\nconst identity$3 = new Mat4();\nclass GLTFSkin extends Mesh {\n  constructor(gl, {\n    skeleton,\n    geometry,\n    program,\n    mode = gl.TRIANGLES\n  } = {}) {\n    super(gl, {\n      geometry,\n      program,\n      mode\n    });\n    this.skeleton = void 0;\n    this.animations = void 0;\n    this.boneMatrices = void 0;\n    this.boneTextureSize = void 0;\n    this.boneTexture = void 0;\n    this.skeleton = skeleton;\n    this.program = program;\n    this.createBoneTexture();\n    this.animations = [];\n  }\n\n  createBoneTexture() {\n    if (!this.skeleton.joints.length) return;\n    const size = Math.max(4, Math.pow(2, Math.ceil(Math.log(Math.sqrt(this.skeleton.joints.length * 4)) / Math.LN2)));\n    this.boneMatrices = new Float32Array(size * size * 4);\n    this.boneTextureSize = size;\n    this.boneTexture = new Texture(this.gl, {\n      image: this.boneMatrices,\n      generateMipmaps: false,\n      type: this.gl.FLOAT,\n      internalFormat: isWebGl2(this.gl) ? this.gl.RGBA32F : this.gl.RGBA,\n      // internalFormat: this.gl.renderer.isWebgl2 ? this.gl.RGBA32F : this.gl.RGBA,\n      flipY: false,\n      width: size\n    });\n  } // addAnimation(data) {\n  //     const animation = new Animation({ objects: this.bones, data });\n  //     this.animations.push(animation);\n  //     return animation;\n  // }\n  // updateAnimations() {\n  //     // Calculate combined animation weight\n  //     let total = 0;\n  //     this.animations.forEach((animation) => (total += animation.weight));\n  //     this.animations.forEach((animation, i) => {\n  //         // force first animation to set in order to reset frame\n  //         animation.update(total, i === 0);\n  //     });\n  // }\n\n\n  updateUniforms() {\n    // Update bone texture\n    this.skeleton.joints.forEach((bone, i) => {\n      // Find difference between current and bind pose\n      tempMat4$3.multiply(bone.worldMatrix, bone.bindInverse);\n      this.boneMatrices.set(tempMat4$3, i * 16);\n    });\n    if (this.boneTexture) this.boneTexture.needsUpdate = true;\n  }\n\n  draw({\n    camera\n  } = {}) {\n    if (!this.program.uniforms.boneTexture) {\n      Object.assign(this.program.uniforms, {\n        boneTexture: {\n          value: this.boneTexture\n        },\n        boneTextureSize: {\n          value: this.boneTextureSize\n        }\n      });\n    }\n\n    this.updateUniforms(); // Switch the world matrix with identity to ignore any transforms\n    // on the mesh itself - only use skeleton's transforms\n\n    const _worldMatrix = this.worldMatrix;\n    this.worldMatrix = identity$3;\n    super.draw({\n      camera\n    }); // Switch back to leave identity untouched\n\n    this.worldMatrix = _worldMatrix;\n  }\n\n}\n\n// Supports\n// [x] Geometry\n// [ ] Sparse support\n// [x] Nodes and Hierarchy\n// [x] Instancing\n// [ ] Morph Targets\n// [x] Skins\n// [ ] Materials\n// [x] Textures\n// [x] Animation\n// [ ] Cameras\n// [ ] Extensions\n// [x] GLB support\n// TODO: Sparse accessor packing? For morph targets basically\n// TODO: init accessor missing bufferView with 0s\n// TODO: morph target animations\n// TODO: what to do if multiple instances are in different groups? Only uses local matrices\n// TODO: what if instancing isn't wanted? Eg collision maps\n// TODO: ie11 fallback for TextDecoder?\nconst TYPE_ARRAY = {\n  5121: Uint8Array,\n  5122: Int16Array,\n  5123: Uint16Array,\n  5125: Uint32Array,\n  5126: Float32Array,\n  'image/jpeg': Uint8Array,\n  'image/png': Uint8Array\n};\nconst TYPE_SIZE = {\n  SCALAR: 1,\n  VEC2: 2,\n  VEC3: 3,\n  VEC4: 4,\n  MAT2: 4,\n  MAT3: 9,\n  MAT4: 16\n};\nconst ATTRIBUTES = {\n  POSITION: 'position',\n  NORMAL: 'normal',\n  TANGENT: 'tangent',\n  TEXCOORD_0: 'uv',\n  TEXCOORD_1: 'uv2',\n  COLOR_0: 'color',\n  WEIGHTS_0: 'skinWeight',\n  JOINTS_0: 'skinIndex'\n};\nconst TRANSFORMS = {\n  translation: 'position',\n  rotation: 'quaternion',\n  scale: 'scale'\n};\nclass GLTFLoader {\n  static async load(gl, src) {\n    const dir = src.split('/').slice(0, -1).join('/') + '/'; // load main description json\n\n    const desc = await this.parseDesc(src);\n    return await this.parse(gl, desc, dir);\n  }\n\n  static async parse(gl, desc, dir) {\n    if (desc.asset === undefined || desc.asset.version[0] < 2) console.warn('Only GLTF >=2.0 supported. Attempting to parse.'); // Load buffers async\n\n    const buffers = await this.loadBuffers(desc, dir); // Unbind current VAO so that new buffers don't get added to active mesh\n\n    gl.renderer.bindVertexArray(null); // Create gl buffers from bufferViews\n\n    const bufferViews = this.parseBufferViews(gl, desc, buffers); // Create images from either bufferViews or separate image files\n\n    const images = this.parseImages(gl, desc, dir, bufferViews);\n    const textures = this.parseTextures(gl, desc, images); // Just pass through material data for now\n\n    const materials = this.parseMaterials(gl, desc, textures); // Fetch the inverse bind matrices for skeleton joints\n\n    const skins = this.parseSkins(gl, desc, bufferViews); // Create geometries for each mesh primitive\n\n    const meshes = this.parseMeshes(gl, desc, bufferViews, materials, skins); // Create transforms, meshes and hierarchy\n\n    const nodes = this.parseNodes(gl, desc, meshes, skins); // Place nodes in skeletons\n\n    this.populateSkins(skins, nodes); // Create animation handlers\n\n    const animations = this.parseAnimations(gl, desc, nodes, bufferViews); // Get top level nodes for each scene\n\n    const scenes = this.parseScenes(desc, nodes);\n    const scene = scenes[desc.scene]; // Remove null nodes (instanced transforms)\n\n    for (let i = nodes.length; i >= 0; i--) if (!nodes[i]) nodes.splice(i, 1);\n\n    return {\n      json: desc,\n      buffers,\n      bufferViews,\n      images,\n      textures,\n      materials,\n      meshes,\n      nodes,\n      animations,\n      scenes,\n      scene\n    };\n  }\n\n  static async parseDesc(src) {\n    if (!src.match(/\\.glb$/)) {\n      return await fetch(src).then(res => res.json());\n    } else {\n      return await fetch(src).then(res => res.arrayBuffer()).then(glb => this.unpackGLB(glb));\n    }\n  } // From https://github.com/donmccurdy/glTF-Transform/blob/e4108cc/packages/core/src/io/io.ts#L32\n\n\n  static unpackGLB(glb) {\n    // Decode and verify GLB header.\n    const header = new Uint32Array(glb, 0, 3);\n\n    if (header[0] !== 0x46546c67) {\n      throw new Error('Invalid glTF asset.');\n    } else if (header[1] !== 2) {\n      throw new Error(`Unsupported glTF binary version, \"${header[1]}\".`);\n    } // Decode and verify chunk headers.\n\n\n    const jsonChunkHeader = new Uint32Array(glb, 12, 2);\n    const jsonByteOffset = 20;\n    const jsonByteLength = jsonChunkHeader[0];\n\n    if (jsonChunkHeader[1] !== 0x4e4f534a) {\n      throw new Error('Unexpected GLB layout.');\n    } // Decode JSON.\n\n\n    const jsonText = new TextDecoder().decode(glb.slice(jsonByteOffset, jsonByteOffset + jsonByteLength));\n    const json = JSON.parse(jsonText); // JSON only\n\n    if (jsonByteOffset + jsonByteLength === glb.byteLength) return json;\n    const binaryChunkHeader = new Uint32Array(glb, jsonByteOffset + jsonByteLength, 2);\n\n    if (binaryChunkHeader[1] !== 0x004e4942) {\n      throw new Error('Unexpected GLB layout.');\n    } // Decode content.\n\n\n    const binaryByteOffset = jsonByteOffset + jsonByteLength + 8;\n    const binaryByteLength = binaryChunkHeader[0];\n    const binary = glb.slice(binaryByteOffset, binaryByteOffset + binaryByteLength); // Attach binary to buffer\n\n    json.buffers[0].binary = binary;\n    return json;\n  } // Threejs GLTF Loader https://github.com/mrdoob/three.js/blob/master/examples/js/loaders/GLTFLoader.js#L1085\n\n\n  static resolveURI(uri, dir) {\n    // Invalid URI\n    if (typeof uri !== 'string' || uri === '') return ''; // Host Relative URI\n\n    if (/^https?:\\/\\//i.test(dir) && /^\\//.test(uri)) {\n      dir = dir.replace(/(^https?:\\/\\/[^\\/]+).*/i, '$1');\n    } // Absolute URI http://, https://, //\n\n\n    if (/^(https?:)?\\/\\//i.test(uri)) return uri; // Data URI\n\n    if (/^data:.*,.*$/i.test(uri)) return uri; // Blob URI\n\n    if (/^blob:.*$/i.test(uri)) return uri; // Relative URI\n\n    return dir + uri;\n  }\n\n  static async loadBuffers(desc, dir) {\n    if (!desc.buffers) return null;\n    return await Promise.all(desc.buffers.map(buffer => {\n      // For GLB, binary buffer ready to go\n      if (buffer.binary) return buffer.binary;\n      const uri = this.resolveURI(buffer.uri, dir);\n      return fetch(uri).then(res => res.arrayBuffer());\n    }));\n  }\n\n  static parseBufferViews(gl, desc, buffers) {\n    if (!desc.bufferViews) return null; // Clone to leave description pure\n\n    const bufferViews = desc.bufferViews.map(o => Object.assign({}, o));\n    desc.meshes && desc.meshes.forEach(({\n      primitives\n    }) => {\n      primitives.forEach(({\n        attributes,\n        indices\n      }) => {\n        // Flag bufferView as an attribute, so it knows to create a gl buffer\n        for (let attr in attributes) bufferViews[desc.accessors[attributes[attr]].bufferView].isAttribute = true;\n\n        if (indices === undefined) return;\n        bufferViews[desc.accessors[indices].bufferView].isAttribute = true; // Make sure indices bufferView have a target property for gl buffer binding\n\n        bufferViews[desc.accessors[indices].bufferView].target = gl.ELEMENT_ARRAY_BUFFER;\n      });\n    }); // Get componentType of each bufferView from the accessors\n\n    desc.accessors.forEach(({\n      bufferView: i,\n      componentType\n    }) => {\n      bufferViews[i].componentType = componentType;\n    }); // Get mimetype of bufferView from images\n\n    desc.images && desc.images.forEach(({\n      uri,\n      bufferView: i,\n      mimeType\n    }) => {\n      if (i === undefined) return;\n      bufferViews[i].mimeType = mimeType;\n    }); // Push each bufferView to the GPU as a separate buffer\n\n    bufferViews.forEach(({\n      buffer: bufferIndex,\n      // required\n      byteOffset = 0,\n      // optional\n      byteLength,\n      // required\n      byteStride,\n      // optional\n      target = gl.ARRAY_BUFFER,\n      // optional, added above for elements\n      name,\n      // optional\n      extensions,\n      // optional\n      extras,\n      // optional\n      componentType,\n      // optional, added from accessor above\n      mimeType,\n      // optional, added from images above\n      isAttribute\n    }, i) => {\n      const TypeArray = TYPE_ARRAY[componentType || mimeType];\n      const elementBytes = TypeArray.BYTES_PER_ELEMENT;\n      const data = new TypeArray(buffers[bufferIndex], byteOffset, byteLength / elementBytes);\n      bufferViews[i].data = data;\n      bufferViews[i].originalBuffer = buffers[bufferIndex];\n      if (!isAttribute) return; // Create gl buffers for the bufferView, pushing it to the GPU\n\n      const buffer = gl.createBuffer();\n      gl.bindBuffer(target, buffer);\n      gl.renderer.state.boundBuffer = buffer;\n      gl.bufferData(target, data, gl.STATIC_DRAW);\n      bufferViews[i].buffer = buffer;\n    });\n    return bufferViews;\n  }\n\n  static parseImages(gl, desc, dir, bufferViews) {\n    if (!desc.images) return null;\n    return desc.images.map(({\n      uri,\n      bufferView: bufferViewIndex,\n      mimeType,\n      name\n    }) => {\n      const image = new Image();\n      image.name = name;\n\n      if (uri) {\n        image.src = this.resolveURI(uri, dir);\n      } else if (bufferViewIndex !== undefined) {\n        const {\n          data\n        } = bufferViews[bufferViewIndex];\n        const blob = new Blob([data], {\n          type: mimeType\n        });\n        image.src = URL.createObjectURL(blob);\n      }\n\n      image.ready = new Promise(res => {\n        image.onload = () => res();\n      });\n      return image;\n    });\n  }\n\n  static parseTextures(gl, desc, images) {\n    if (!desc.textures) return null;\n    return desc.textures.map(({\n      sampler: samplerIndex,\n      source: sourceIndex,\n      name,\n      extensions,\n      extras\n    }) => {\n      const options = {\n        flipY: false,\n        wrapS: gl.REPEAT,\n        // Repeat by default, opposed to OGL's clamp by default\n        wrapT: gl.REPEAT\n      };\n      const sampler = samplerIndex !== undefined ? desc.samplers[samplerIndex] : null;\n\n      if (sampler) {\n        ['magFilter', 'minFilter', 'wrapS', 'wrapT'].forEach(prop => {\n          if (sampler[prop]) options[prop] = sampler[prop];\n        });\n      }\n\n      const texture = new Texture(gl, options);\n      texture.name = name;\n      const image = images[sourceIndex];\n      image.ready.then(() => texture.image = image);\n      return texture;\n    });\n  }\n\n  static parseMaterials(gl, desc, textures) {\n    if (!desc.materials) return null;\n    return desc.materials.map(({\n      name,\n      extensions,\n      extras,\n      pbrMetallicRoughness = {},\n      normalTexture,\n      occlusionTexture,\n      emissiveTexture,\n      emissiveFactor = [0, 0, 0],\n      alphaMode = 'OPAQUE',\n      alphaCutoff = 0.5,\n      doubleSided = false\n    }) => {\n      const {\n        baseColorFactor = [1, 1, 1, 1],\n        baseColorTexture,\n        metallicFactor = 1,\n        roughnessFactor = 1,\n        metallicRoughnessTexture //   extensions,\n        //   extras,\n\n      } = pbrMetallicRoughness;\n\n      if (baseColorTexture) {\n        baseColorTexture.texture = textures[baseColorTexture.index]; // texCoord\n      }\n\n      if (normalTexture) {\n        normalTexture.texture = textures[normalTexture.index]; // scale: 1\n        // texCoord\n      }\n\n      if (metallicRoughnessTexture) {\n        metallicRoughnessTexture.texture = textures[metallicRoughnessTexture.index]; // texCoord\n      }\n\n      if (occlusionTexture) {\n        occlusionTexture.texture = textures[occlusionTexture.index]; // strength 1\n        // texCoord\n      }\n\n      if (emissiveTexture) {\n        emissiveTexture.texture = textures[emissiveTexture.index]; // texCoord\n      }\n\n      return {\n        name,\n        baseColorFactor,\n        baseColorTexture,\n        metallicFactor,\n        roughnessFactor,\n        metallicRoughnessTexture,\n        normalTexture,\n        occlusionTexture,\n        emissiveTexture,\n        emissiveFactor,\n        alphaMode,\n        alphaCutoff,\n        doubleSided\n      };\n    });\n  }\n\n  static parseSkins(gl, desc, bufferViews) {\n    if (!desc.skins) return null;\n    return desc.skins.map(({\n      inverseBindMatrices,\n      // optional\n      skeleton,\n      // optional\n      joints // required\n      // name,\n      // extensions,\n      // extras,\n\n    }) => {\n      return {\n        inverseBindMatrices: this.parseAccessor(inverseBindMatrices, desc, bufferViews),\n        skeleton,\n        joints\n      };\n    });\n  }\n\n  static parseMeshes(gl, desc, bufferViews, materials, skins) {\n    if (!desc.meshes) return null;\n    return desc.meshes.map(({\n      primitives,\n      // required\n      weights,\n      // optional\n      name,\n      // optional\n      extensions,\n      // optional\n      extras // optional\n\n    }, meshIndex) => {\n      // TODO: weights stuff ?\n      // Parse through nodes to see how many instances there are\n      // and if there is a skin attached\n      let numInstances = 0;\n      let skinIndex = false;\n      desc.nodes && desc.nodes.forEach(({\n        mesh,\n        skin\n      }) => {\n        if (mesh === meshIndex) {\n          numInstances++;\n          if (skin !== undefined) skinIndex = skin;\n        }\n      });\n      primitives = this.parsePrimitives(gl, primitives, desc, bufferViews, materials, numInstances).map(({\n        geometry,\n        program,\n        mode\n      }) => {\n        // Create either skinned mesh or regular mesh\n        const mesh = typeof skinIndex === 'number' ? new GLTFSkin(gl, {\n          skeleton: skins[skinIndex],\n          geometry,\n          program,\n          mode\n        }) : new Mesh(gl, {\n          geometry,\n          program,\n          mode\n        });\n        mesh.name = name;\n\n        if (mesh.geometry.isInstanced) {\n          // Tag mesh so that nodes can add their transforms to the instance attribute\n          mesh.numInstances = numInstances; // Avoid incorrect culling for instances\n\n          mesh.frustumCulled = false;\n        }\n\n        return mesh;\n      });\n      return {\n        primitives,\n        weights,\n        name\n      };\n    });\n  }\n\n  static parsePrimitives(gl, primitives, desc, bufferViews, materials, numInstances) {\n    return primitives.map(({\n      attributes,\n      // required\n      indices,\n      // optional\n      material: materialIndex,\n      // optional\n      mode = 4,\n      // optional\n      targets,\n      // optional\n      extensions,\n      // optional\n      extras // optional\n\n    }) => {\n      const geometry = new Geometry(gl); // Add each attribute found in primitive\n\n      for (let attr in attributes) {\n        geometry.addAttribute(ATTRIBUTES[attr], this.parseAccessor(attributes[attr], desc, bufferViews));\n      } // Add index attribute if found\n\n\n      if (indices !== undefined) {\n        geometry.addAttribute('index', this.parseAccessor(indices, desc, bufferViews));\n      } // Add instanced transform attribute if multiple instances\n\n\n      if (numInstances > 1) {\n        geometry.addAttribute('instanceMatrix', {\n          instanced: 1,\n          size: 16,\n          data: new Float32Array(numInstances * 16)\n        });\n      } // TODO: materials\n      // const program = new NormalProgram(gl);\n\n\n      const program = NormalProgram(gl);\n\n      if (materialIndex !== undefined) {\n        program.gltfMaterial = materials[materialIndex];\n      }\n\n      return {\n        geometry,\n        program,\n        mode\n      };\n    });\n  }\n\n  static parseAccessor(index, desc, bufferViews) {\n    // TODO: init missing bufferView with 0s\n    // TODO: support sparse\n    const {\n      bufferView: bufferViewIndex,\n      // optional\n      byteOffset = 0,\n      // optional\n      componentType,\n      // required\n      normalized = false,\n      // optional\n      count,\n      // required\n      type,\n      // required\n      min,\n      // optional\n      max,\n      // optional\n      sparse // optional\n      // name, // optional\n      // extensions, // optional\n      // extras, // optional\n\n    } = desc.accessors[index];\n    const {\n      data,\n      // attached in parseBufferViews\n      originalBuffer,\n      // attached in parseBufferViews\n      buffer,\n      // replaced to be the actual GL buffer\n      byteOffset: bufferByteOffset = 0,\n      // byteLength, // applied in parseBufferViews\n      byteStride = 0,\n      target // name,\n      // extensions,\n      // extras,\n\n    } = bufferViews[bufferViewIndex];\n    const size = TYPE_SIZE[type]; // Parse data from joined buffers\n\n    const TypeArray = TYPE_ARRAY[componentType];\n    const elementBytes = data.BYTES_PER_ELEMENT;\n    const componentStride = byteStride / elementBytes;\n    const isInterleaved = !!byteStride && componentStride !== size; // TODO: interleaved\n\n    const newData = isInterleaved ? data : new TypeArray(originalBuffer, byteOffset + bufferByteOffset, count * size); // Return attribute data\n\n    return {\n      data: newData,\n      size,\n      type: componentType,\n      normalized,\n      buffer,\n      stride: byteStride,\n      offset: byteOffset,\n      count,\n      min,\n      max\n    };\n  }\n\n  static parseNodes(gl, desc, meshes, skins) {\n    if (!desc.nodes) return null;\n    const nodes = desc.nodes.map(({\n      camera,\n      // optional\n      children,\n      // optional\n      skin: skinIndex,\n      // optional\n      matrix,\n      // optional\n      mesh: meshIndex,\n      // optional\n      rotation,\n      // optional\n      scale,\n      // optional\n      translation,\n      // optional\n      weights,\n      // optional\n      name,\n      // optional\n      extensions,\n      // optional\n      extras // optional\n\n    }) => {\n      const node = new Transform();\n      if (name) node.name = name; // Apply transformations\n\n      if (matrix) {\n        node.matrix.copy(matrix);\n        node.decompose();\n      } else {\n        if (rotation) node.quaternion.copy(rotation);\n        if (scale) node.scale.copy(scale);\n        if (translation) node.position.copy(translation);\n        node.updateMatrix();\n      } // Flags for avoiding duplicate transforms and removing unused instance nodes\n\n\n      let isInstanced = false;\n      let isFirstInstance = true; // add mesh if included\n\n      if (meshIndex !== undefined) {\n        meshes[meshIndex].primitives.forEach(mesh => {\n          if (mesh.geometry.isInstanced) {\n            isInstanced = true;\n\n            if (!mesh.instanceCount) {\n              mesh.instanceCount = 0;\n            } else {\n              isFirstInstance = false;\n            }\n\n            node.matrix.toArray(mesh.geometry.attributes.instanceMatrix.data, mesh.instanceCount * 16);\n            mesh.instanceCount++;\n\n            if (mesh.instanceCount === mesh.numInstances) {\n              // Remove properties once all instances added\n              delete mesh.numInstances;\n              delete mesh.instanceCount; // Flag attribute as dirty\n\n              mesh.geometry.attributes.instanceMatrix.needsUpdate = true;\n            }\n          } // For instances, only the first node will actually have the mesh\n\n\n          if (isInstanced) {\n            if (isFirstInstance) mesh.setParent(node);\n          } else {\n            mesh.setParent(node);\n          }\n        });\n      } // Reset node if instanced to not duplicate transforms\n\n\n      if (isInstanced) {\n        // Remove unused nodes just providing an instance transform\n        if (!isFirstInstance) return null; // Avoid duplicate transform for node containing the instanced mesh\n\n        node.matrix.identity();\n        node.decompose();\n      }\n\n      return node;\n    });\n    desc.nodes.forEach(({\n      children = []\n    }, i) => {\n      // Set hierarchy now all nodes created\n      children.forEach(childIndex => {\n        if (!nodes[childIndex]) return;\n        nodes[childIndex].setParent(nodes[i]);\n      });\n    });\n    return nodes;\n  }\n\n  static populateSkins(skins, nodes) {\n    if (!skins) return;\n    skins.forEach(skin => {\n      skin.joints = skin.joints.map((i, index) => {\n        const joint = nodes[i];\n        joint.bindInverse = new Mat4(...skin.inverseBindMatrices.data.slice(index * 16, (index + 1) * 16));\n        return joint;\n      });\n      if (skin.skeleton) skin.skeleton = nodes[skin.skeleton];\n    });\n  }\n\n  static parseAnimations(gl, desc, nodes, bufferViews) {\n    if (!desc.animations) return null;\n    return desc.animations.map(({\n      channels,\n      // required\n      samplers,\n      // required\n      name // optional\n      // extensions, // optional\n      // extras,  // optional\n\n    }) => {\n      const data = channels.map(({\n        sampler: samplerIndex,\n        // required\n        target // required\n        // extensions, // optional\n        // extras, // optional\n\n      }) => {\n        const {\n          input: inputIndex,\n          // required\n          interpolation = 'LINEAR',\n          output: outputIndex // required\n          // extensions, // optional\n          // extras, // optional\n\n        } = samplers[samplerIndex];\n        const {\n          node: nodeIndex,\n          // optional - TODO: when is it not included?\n          path // required\n          // extensions, // optional\n          // extras, // optional\n\n        } = target;\n        const node = nodes[nodeIndex];\n        const transform = TRANSFORMS[path];\n        const times = this.parseAccessor(inputIndex, desc, bufferViews).data;\n        const values = this.parseAccessor(outputIndex, desc, bufferViews).data;\n        return {\n          node,\n          transform,\n          interpolation,\n          times,\n          values\n        };\n      });\n      return {\n        name,\n        animation: new GLTFAnimation(data)\n      };\n    });\n  }\n\n  static parseScenes(desc, nodes) {\n    if (!desc.scenes) return null;\n    return desc.scenes.map(({\n      nodes: nodesIndices = [],\n      name,\n      // optional\n      extensions,\n      extras\n    }) => {\n      return nodesIndices.reduce((map, i) => {\n        // Don't add null nodes (instanced transforms)\n        if (nodes[i]) map.push(nodes[i]);\n        return map;\n      }, []);\n    });\n  }\n\n}\n\nexport { Animation, Box, Camera, Color, Curve, Cylinder, Euler, Flowmap, GLTFAnimation, GLTFLoader, GLTFSkin, GPGPU, Geometry, KTXTexture, Mat3, Mat4, Mesh, NormalProgram, Orbit, Plane, Polyline, Post, Program, Quat, Raycast, RenderTarget, Renderer, Shadow, Skin, Sphere, Text, Texture, TextureLoader, Torus, Transform, Triangle, Vec2, Vec3, Vec4 };\n","import { noise, arbitraryRotate } from '@plantarium/geometry';\nimport { logger } from '@plantarium/helpers';\nimport { GeometryResult, PlantNode } from '@types';\nimport { Vec3 } from 'ogl-typescript';\n\nconst log = logger('node.gravity');\n\nconst node: PlantNode = {\n  name: 'Gravity',\n  type: 'gravity',\n\n  outputs: ['plant'],\n\n  state: {\n    input: {\n      type: 'pd',\n    },\n  },\n  computeNode(parameters) {\n    return {\n      type: 'gravity',\n      parameters,\n    };\n  },\n  computeSkeleton(part) {\n    const { input, type } = part.parameters;\n    const strength = 0.5;\n    // const stemResY = settings.getSetting('stemResY');\n\n    log(type, strength);\n\n    const {\n      result: { skeletons: inputSkeletons },\n    } = input as GeometryResult;\n    if (type === 'simple') {\n      const skeletons = inputSkeletons.map((skelly, j) => {\n        const amount = skelly.length / 4;\n\n        // Loop over every single joint in the skeleton\n        for (let i = 1; i < amount; i++) {\n          const x = skelly[i * 4 + 0];\n          const y = skelly[i * 4 + 1];\n          const z = skelly[i * 4 + 2];\n\n          const origin = [skelly[0], skelly[1], skelly[2]];\n\n          const a = i / amount;\n\n          const gravityAngle = noise.n1d(j * 200) * strength * a;\n          skelly[i * 4 + 0] =\n            Math.cos(gravityAngle) * (x - origin[0]) -\n            Math.sin(gravityAngle) * (y - origin[1]) +\n            origin[0];\n          skelly[i * 4 + 1] =\n            Math.sin(gravityAngle) * (x - origin[0]) +\n            Math.cos(gravityAngle) * (y - origin[1]) +\n            origin[1];\n          skelly[i * 4 + 2] = z;\n        }\n\n        return skelly;\n      });\n\n      return {\n        skeletons,\n      };\n    }\n\n    const skeletons = inputSkeletons.map((skelly) => {\n      const amount = skelly.length / 4;\n\n      // Loop over every single joint in the skeleton\n      for (let i = 1; i < amount; i++) {\n        const x = skelly[i * 4 + 0];\n        const y = skelly[i * 4 + 1];\n        const z = skelly[i * 4 + 2];\n\n        const axis = new Vec3(5, 0, 0).cross(\n          new Vec3(x, y, z),\n          new Vec3(0, 1, 0),\n        );\n\n        //Rotate all the other joints\n        for (let j = i; j < amount; j++) {\n          const rot = arbitraryRotate([x, y, z], 0, axis);\n\n          skelly[j * 4 + 0] = rot[0];\n          skelly[j * 4 + 1] = rot[1];\n          skelly[j * 4 + 2] = rot[2];\n        }\n      }\n\n      return skelly;\n    });\n\n    return {\n      skeletons,\n    };\n  },\n};\n\nexport default node;\n","import { PlantNode } from '@types';\nimport * as nodes from './nodes';\nconst _nodes = Object.values(nodes) as PlantNode[];\nexport default _nodes;\n","import { join, tube } from '@plantarium/geometry';\nimport { PlantNode } from '@types';\n\nconst node: PlantNode = {\n  name: 'Stem',\n  type: 'stem',\n  outputs: ['plant'],\n  state: {\n    origin: {\n      type: 'vec3',\n      internal: false,\n    },\n    height: {\n      type: 'number',\n      inputType: 'slider',\n      min: 0,\n      max: 5,\n      step: 0.05,\n      value: 0,\n    },\n    thiccness: {\n      type: 'number',\n      inputType: 'slider',\n      min: 0,\n      max: 0.2,\n      step: 0.01,\n      value: 0,\n    },\n    amount: {\n      type: 'number',\n      min: 0,\n      max: 20,\n      value: 1,\n    },\n  },\n  computeNode(parameters) {\n    return {\n      type: 'stem',\n      parameters,\n    };\n  },\n\n  computeSkeleton(part, ctx) {\n    // const {} = part.parameters;\n\n    const origin = { x: 0, y: 0, z: 0 };\n    const height = 3;\n    const thiccness = 0.4;\n    const amount = 1;\n\n    // const { stemResY: amountPoints = 50 } = settings;\n\n    const amountPoints = ctx.getSetting('stemResY');\n\n    const skeletons = [];\n\n    for (let i = 0; i < amount; i++) {\n      const skeleton = new Float32Array(amountPoints * 4);\n\n      for (let j = 0; j < amountPoints; j++) {\n        const a = j / amountPoints;\n\n        //Create point\n        const x = origin.x;\n        const y = origin.z + a * height;\n        const z = origin.y;\n\n        skeleton[j * 4 + 0] = x;\n        skeleton[j * 4 + 1] = y;\n        skeleton[j * 4 + 2] = z;\n        skeleton[j * 4 + 3] = (1 - a) * thiccness;\n      }\n\n      skeletons.push(skeleton);\n    }\n\n    return {\n      skeletons,\n    };\n  },\n\n  computeGeometry(part, ctx) {\n    const stemResX = ctx.getSetting('stemResX');\n\n    return {\n      geometry: join(\n        ...part.result.skeletons.map((skelly) => tube(skelly, stemResX)),\n      ),\n    };\n  },\n};\n\nexport default node;\n","import { PlantNode } from '@types';\n\nconst node: PlantNode = {\n  name: 'Output',\n  type: 'output',\n  outputs: [],\n  state: {\n    main: {\n      type: 'plant',\n      label: 'plant',\n      internal: false,\n    },\n  },\n  computeNode(parameters) {\n    return {\n      type: 'output',\n      parameters,\n    };\n  },\n};\n\nexport default node;\n"],"names":["node","name","type","outputs","state","input","label","internal","length","inputType","min","max","step","value","thiccness","amount","computeNode","parameters","computeSkeleton","part","skeletons","result","map","skelly","branches","i","interpolateSkeleton","x","y","z","t","branch","Float32Array","branchRes","j","_a","push","flat","console","log","computeGeometry","ctx","stemResX","getSetting","geometry","join","skeleton","tube","a","Math","sqrt","copy","out","add","b","subtract","scale","squaredLength","normalize","len","dot","cross","ax","ay","az","bx","by","bz","tempA","tempB","angle","cosine","PI","acos","Vec3","_this2","constant","set","this","v","va","vb","sub","multiply","divide","inverse","distance","squaredLen","squaredDistance","negate","equals","applyMatrix4","mat4","m","w","scaleRotateMatrix4","applyQuaternion","q","qx","qy","qz","uvx","uvy","uvz","uuvx","uuvy","uuvz","w2","transformQuat","lerp","clone","fromArray","o","toArray","transformDirection","Array","multiply$1","a00","a01","a02","a03","a10","a11","a12","a13","a20","a21","a22","a23","a30","a31","a32","a33","b0","b1","b2","b3","getScaling","mat","m21","m22","m23","m31","m32","m33","hypot","temp","getRotation","scaling","is1","is2","is3","sm11","sm12","sm13","sm21","sm22","sm23","sm31","sm32","sm33","trace","S","Mat4","m00","m01","m02","m03","m10","m11","m12","m13","m20","m30","_this6","set$1","translate","rotate","axis","rad","s","c","b00","b01","b02","b10","b11","b12","b20","b21","b22","abs","sin","cos","scale$1","ma","mb","identity","fromPerspective","aspect","near","far","f","nf","tan","fov","fromOrthogonal","bt","bottom","top","lr","left","right","fromQuaternion","x2","y2","z2","xx","yx","yy","zx","zy","zz","wx","wy","wz","fromQuat","setPosition","b03","b04","b05","b06","b07","b08","b09","det","compose","pos","xy","xz","yz","sx","sy","sz","fromRotationTranslationScale","getTranslation","getMaxScaleOnAxis","lookAt","eye","target","up","eyex","eyey","eyez","upx","upy","upz","z0","z1","x0","x1","targetTo","determinant","multiply$2","aw","bw","Quat","_this7","onChange","set$3","rotateX","rotateY","rotateZ","a0","a1","a2","a3","invDot","conjugate","qA","qB","fromMatrix3","matrix3","fRoot","fTrace","k","fromMat3","fromEuler","euler","order","cx","cy","cz","fromAxisAngle","setAxisAngle","slerp","omega","cosom","sinom","scale0","scale1","add$1","subtract$1","scale$3","length$1","cross$1","Vec2","_this15","set$5","squaredLength$1","applyMatrix3","mat3","lerp$1","logger","_nodes","Object","values","inputSkeletons","origin","gravityAngle","noise","n1d","rot","arbitraryRotate","height","amountPoints","main"],"mappings":"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"}